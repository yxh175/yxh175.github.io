<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小黑的随笔</title>
  
  <subtitle>去热爱生活    去追寻极致    去坚守本心</subtitle>
  <link href="http://xiaoheinotes.com/atom.xml" rel="self"/>
  
  <link href="http://xiaoheinotes.com/"/>
  <updated>2023-10-17T11:30:34.826Z</updated>
  <id>http://xiaoheinotes.com/</id>
  
  <author>
    <name>xiaohei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试经验：苏小妍</title>
    <link href="http://xiaoheinotes.com/2023/10/17/interview-experience-suxiaoyan/"/>
    <id>http://xiaoheinotes.com/2023/10/17/interview-experience-suxiaoyan/</id>
    <published>2023-10-17T08:20:10.000Z</published>
    <updated>2023-10-17T11:30:34.826Z</updated>
    
    <content type="html"><![CDATA[<p>2023年10月17日golang开发工程师 苏小妍一面</p><p><strong>注意</strong>：一定要检查自己的腾讯会议的名字，不要是自己的本人的名字。否则真的很尴尬。甚至有可能因此挂掉。</p><p>总共有两个面试官，一个主面试官，一个副面试官。</p><p>主面试官问的语言层面（很偏、感觉大受震撼），副面试官问的是实习与其他八股相关</p><h2 id="主面试官"><a href="#主面试官" class="headerlink" title="主面试官"></a>主面试官</h2><h3 id="slice-中nil和空的区别？"><a href="#slice-中nil和空的区别？" class="headerlink" title="slice 中nil和空的区别？"></a>slice 中nil和空的区别？</h3><ul><li>slice是nil的时候是没有指向任何实例的</li><li>slice为空的时候，是可以存在slice的，只不过这个slice里面是空的</li></ul><h3 id="一个nil的slice的在序列化会出现什么？"><a href="#一个nil的slice的在序列化会出现什么？" class="headerlink" title="一个nil的slice的在序列化会出现什么？"></a>一个nil的slice的在序列化会出现什么？</h3><p>一个nil的slice在序列化的时候理论上来说会出现空指针异常，不多说测一测</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSliceJson</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> sNil []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;sNil is&quot;</span>, sNil == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// res是[]byte类型</span></span><br><span class="line">res, err := json.Marshal(sNil)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="type">string</span>(res))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line"><span class="comment">// === RUN   TestSliceJson</span></span><br><span class="line"><span class="comment">// sNil is true</span></span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="comment">// --- PASS: TestSliceJson (0.00s)</span></span><br><span class="line"><span class="comment">// PASS</span></span><br></pre></td></tr></table></figure><p>发现输出结果是null，绷不住了我回答的是空指针异常</p><h3 id="slice-遍历时，append会出现死循环吗？"><a href="#slice-遍历时，append会出现死循环吗？" class="headerlink" title="slice 遍历时，append会出现死循环吗？"></a>slice 遍历时，append会出现死循环吗？</h3><p>当使用range遍历时和使用<code>for i := 0; i &lt; len(s); i ++</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSliceAppend</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// range</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通for循环</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s) &amp;&amp; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, i)</span><br><span class="line">fmt.Println(s[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// range</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 普通for循环</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// 6</span></span><br><span class="line"><span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 8</span></span><br><span class="line"><span class="comment">// 9</span></span><br><span class="line"><span class="comment">// 10</span></span><br></pre></td></tr></table></figure><p>可以看到range是不会出现死循环，但是普通的for循环就会死循环。</p><p>机理上不同的原因是：</p><ul><li>range range相当于是快照，一种值拷贝所以不会感知到append的结果</li><li>for 相当于是对i的控制，每一次会进行一种对比</li></ul><h3 id="map是并发安全的吗？"><a href="#map是并发安全的吗？" class="headerlink" title="map是并发安全的吗？"></a>map是并发安全的吗？</h3><p>不是，为了解决这种并发安全问题，通常使用<code>sync.Map</code>或者使用<code>sync.RWMutex</code>进行锁之间的冲突解决</p><h3 id="sync-Map底层原理？"><a href="#sync-Map底层原理？" class="headerlink" title="sync.Map底层原理？"></a>sync.Map底层原理？</h3><p>给自己挖坑了，没答上来</p><p>百度一下这篇文章写的很详细<a href="https://segmentfault.com/a/1190000043764275">Sync.Map底层</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">   mu Mutex <span class="comment">// 锁，保证写操作及dirty晋升为read的线程安全</span></span><br><span class="line"></span><br><span class="line">   read atomic.Value <span class="comment">// readOnly 只读map</span></span><br><span class="line"></span><br><span class="line">   dirty <span class="keyword">map</span>[any]*entry <span class="comment">// 脏map，当内部有数据时就一定包含read中的数据</span></span><br><span class="line"></span><br><span class="line">   misses <span class="type">int</span> <span class="comment">// read未命中次数，当达到一定次数时会触发dirty中的护具晋升到read</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到主要的思想是一个锁，一个<code>read map</code>和<code>dirty map</code>，当内部有数据时，一定包含read中的数据。<br>&#96;</p><h3 id="dirtyMap是什么-sync-Map的底层-？"><a href="#dirtyMap是什么-sync-Map的底层-？" class="headerlink" title="dirtyMap是什么(sync.Map的底层)？"></a>dirtyMap是什么(sync.Map的底层)？</h3><p>底层没看T-T</p><h3 id="defer-会修改return的返回值吗"><a href="#defer-会修改return的返回值吗" class="headerlink" title="defer 会修改return的返回值吗"></a>defer 会修改return的返回值吗</h3><p>跟面试官说了一下整体的顺序，如果是一个变量，是会修改返回的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestXxx</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;test1: &quot;</span>, deferTest1())</span><br><span class="line">fmt.Println(<span class="string">&quot;test2: &quot;</span>, deferTest2())</span><br><span class="line">fmt.Println(<span class="string">&quot;test3: &quot;</span>, deferTest3())</span><br><span class="line">fmt.Println(<span class="string">&quot;test4: &quot;</span>, deferTest4())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest1</span><span class="params">()</span></span> (x <span class="type">int</span>) &#123;</span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest2</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">x = <span class="number">100</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest3</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">r = <span class="number">100</span></span><br><span class="line">&#125;(x)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deferTest4</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">x := <span class="number">0</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(r *<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">*r = <span class="number">100</span></span><br><span class="line">&#125;(&amp;x)</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test1:  100</span></span><br><span class="line"><span class="comment">// test2:  0</span></span><br><span class="line"><span class="comment">// test3:  0</span></span><br><span class="line"><span class="comment">// test4:  0</span></span><br></pre></td></tr></table></figure><p>之后大概测试了一下，发现只有在返回值是在刚开始就确定好的话，就会导致返回结果被修改</p><h2 id="副面试官"><a href="#副面试官" class="headerlink" title="副面试官"></a>副面试官</h2><h3 id="链表反转如何实现（简述算法思路）？"><a href="#链表反转如何实现（简述算法思路）？" class="headerlink" title="链表反转如何实现（简述算法思路）？"></a>链表反转如何实现（简述算法思路）？</h3><p>pre 记录前节点<br>now 记录当前节点<br>nxt 记录下一个节点</p><p>依次前推</p><h3 id="挖实习"><a href="#挖实习" class="headerlink" title="挖实习"></a>挖实习</h3><h3 id="问docker和k8s是什么，他们之间的关系？"><a href="#问docker和k8s是什么，他们之间的关系？" class="headerlink" title="问docker和k8s是什么，他们之间的关系？"></a>问docker和k8s是什么，他们之间的关系？</h3><p>Docker和K8S之间是一种协同的关系，Docker负责应用级的容器构建、打包，K8S负责容器编排和容器管理</p><h3 id="docker和虚拟机的区别？"><a href="#docker和虚拟机的区别？" class="headerlink" title="docker和虚拟机的区别？"></a>docker和虚拟机的区别？</h3><p>往深的讲了，面试官说不用讲这么深，简单说一下就行了</p><h3 id="从使用角度来说"><a href="#从使用角度来说" class="headerlink" title="从使用角度来说"></a>从使用角度来说</h3><ul><li>结构不同</li><li>部署速度</li><li>可移植性</li><li>隔离性</li></ul><h3 id="K8S是做什么的，有没有使用过"><a href="#K8S是做什么的，有没有使用过" class="headerlink" title="K8S是做什么的，有没有使用过"></a>K8S是做什么的，有没有使用过</h3><p>容器编排的，之前在公司使用过，不过是一件部署的</p><p>全程17分钟，很快哈哈，光速挂难道？</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年10月17日golang开发工程师 苏小妍一面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：一定要检查自己的腾讯会议的名字，不要是自己的本人的名字。否则真的很尴尬。甚至有可能因此挂掉。&lt;/p&gt;
&lt;p&gt;总共有两个面试官，一个主面试官，一个副面试官。&lt;/p&gt;</summary>
      
    
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试经验：集度</title>
    <link href="http://xiaoheinotes.com/2023/10/17/interview-experience-jidu/"/>
    <id>http://xiaoheinotes.com/2023/10/17/interview-experience-jidu/</id>
    <published>2023-10-17T07:21:47.000Z</published>
    <updated>2023-10-17T10:12:45.845Z</updated>
    
    <content type="html"><![CDATA[<p>2023年10月17日集度一面</p><p>面试整体面试回答情况一般，大概率是凉经。这里简单记录一下</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>简单的自我介绍</p><h2 id="问技术栈"><a href="#问技术栈" class="headerlink" title="问技术栈"></a>问技术栈</h2><p>因为武汉的岗位是java的，所以面试官想推我去北京，大概问了我一下，然后就是专业问题，因为跨考生，所以问一下基础问题。</p><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="进程与线程的区别？"><a href="#进程与线程的区别？" class="headerlink" title="进程与线程的区别？"></a>进程与线程的区别？</h3><h3 id="进程之间如何通信？"><a href="#进程之间如何通信？" class="headerlink" title="进程之间如何通信？"></a>进程之间如何通信？</h3><h3 id="管道是怎么实现的？"><a href="#管道是怎么实现的？" class="headerlink" title="管道是怎么实现的？"></a>管道是怎么实现的？</h3><h3 id="进程之间是怎么切换的？"><a href="#进程之间是怎么切换的？" class="headerlink" title="进程之间是怎么切换的？"></a>进程之间是怎么切换的？</h3><h3 id="操作系统中内存管理？"><a href="#操作系统中内存管理？" class="headerlink" title="操作系统中内存管理？"></a>操作系统中内存管理？</h3><h3 id="段和页的区别？"><a href="#段和页的区别？" class="headerlink" title="段和页的区别？"></a>段和页的区别？</h3><h3 id="什么是栈，什么是堆？"><a href="#什么是栈，什么是堆？" class="headerlink" title="什么是栈，什么是堆？"></a>什么是栈，什么是堆？</h3><h3 id="什么是栈，什么是队列？"><a href="#什么是栈，什么是队列？" class="headerlink" title="什么是栈，什么是队列？"></a>什么是栈，什么是队列？</h3><h3 id="在操作系统中哪些有体现？"><a href="#在操作系统中哪些有体现？" class="headerlink" title="在操作系统中哪些有体现？"></a>在操作系统中哪些有体现？</h3><h3 id="七层网络结构"><a href="#七层网络结构" class="headerlink" title="七层网络结构"></a>七层网络结构</h3><h3 id="TCP在那一层？"><a href="#TCP在那一层？" class="headerlink" title="TCP在那一层？"></a>TCP在那一层？</h3><h3 id="TCP-和-UDP的区别？"><a href="#TCP-和-UDP的区别？" class="headerlink" title="TCP 和 UDP的区别？"></a>TCP 和 UDP的区别？</h3><h3 id="Mysql有什么索引？"><a href="#Mysql有什么索引？" class="headerlink" title="Mysql有什么索引？"></a>Mysql有什么索引？</h3><h3 id="索引的结构是什么？"><a href="#索引的结构是什么？" class="headerlink" title="索引的结构是什么？"></a>索引的结构是什么？</h3><h3 id="事务隔离级别有哪些？"><a href="#事务隔离级别有哪些？" class="headerlink" title="事务隔离级别有哪些？"></a>事务隔离级别有哪些？</h3><h3 id="四种隔离级别有什么区别？"><a href="#四种隔离级别有什么区别？" class="headerlink" title="四种隔离级别有什么区别？"></a>四种隔离级别有什么区别？</h3><h3 id="undo-log-和-redo-log的区别？"><a href="#undo-log-和-redo-log的区别？" class="headerlink" title="undo log 和 redo log的区别？"></a>undo log 和 redo log的区别？</h3><h2 id="挖实习"><a href="#挖实习" class="headerlink" title="挖实习"></a>挖实习</h2><h3 id="在石墨大概做了什么，简单讲一下"><a href="#在石墨大概做了什么，简单讲一下" class="headerlink" title="在石墨大概做了什么，简单讲一下"></a>在石墨大概做了什么，简单讲一下</h3><h3 id="这期间有没有遇到什么问题？"><a href="#这期间有没有遇到什么问题？" class="headerlink" title="这期间有没有遇到什么问题？"></a>这期间有没有遇到什么问题？</h3><h3 id="这个问题是怎么出现的？"><a href="#这个问题是怎么出现的？" class="headerlink" title="这个问题是怎么出现的？"></a>这个问题是怎么出现的？</h3><h3 id="有没有影响到线上？"><a href="#有没有影响到线上？" class="headerlink" title="有没有影响到线上？"></a>有没有影响到线上？</h3><h3 id="有什么收获？"><a href="#有什么收获？" class="headerlink" title="有什么收获？"></a>有什么收获？</h3><h3 id="具体学到了什么？"><a href="#具体学到了什么？" class="headerlink" title="具体学到了什么？"></a>具体学到了什么？</h3><h2 id="手撕"><a href="#手撕" class="headerlink" title="手撕"></a>手撕</h2><p><a href="https://leetcode.cn/problems/sqrtx/">leetcode 69.x的平方根</a></p><h2 id="有什么兴趣爱好"><a href="#有什么兴趣爱好" class="headerlink" title="有什么兴趣爱好"></a>有什么兴趣爱好</h2><h2 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h2><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>面的不是太好，操作系统部分面的稀烂，感觉大概率是凉了，之后要好好看看相关的知识点了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年10月17日集度一面&lt;/p&gt;
&lt;p&gt;面试整体面试回答情况一般，大概率是凉经。这里简单记录一下&lt;/p&gt;
&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=&quot;自我介绍&quot;&gt;&lt;/a&gt;自我介绍&lt;/h2&gt;&lt;p&gt;简单的</summary>
      
    
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>GO底层剖析：Map底层实现</title>
    <link href="http://xiaoheinotes.com/2023/10/16/go-map-keypoint/"/>
    <id>http://xiaoheinotes.com/2023/10/16/go-map-keypoint/</id>
    <published>2023-10-16T10:42:00.000Z</published>
    <updated>2023-10-16T13:07:45.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><p>Map在面试中被问到的东西挺多的，常见的就有</p><ul><li>map并发安全</li><li>map底层实现</li><li>map扩容规则</li></ul><p>map其实可以理解为一种哈希表的数据结构。</p><h3 id="如何设计一个Map"><a href="#如何设计一个Map" class="headerlink" title="如何设计一个Map"></a>如何设计一个Map</h3><p>Map既然是一种哈希表的数据结构，通常在设计它的时候需要注意两个点</p><ul><li>哈希函数的选择</li><li>哈希冲突的解决</li></ul><p>那么golang在这里是如何解决这些问题的呢？</p><h3 id="Golang中Map的设计"><a href="#Golang中Map的设计" class="headerlink" title="Golang中Map的设计"></a>Golang中Map的设计</h3><p>首先先翻看一下Map的源码实现</p><p>在Go的<code>runtime.hmap</code>是最核心的结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">count     <span class="type">int</span>   <span class="comment">// 表示当前hash表的元素数量</span></span><br><span class="line">flags     <span class="type">uint8</span>     </span><br><span class="line">B         <span class="type">uint8</span>     <span class="comment">// 表示当前buckets的数量，但是B是次方上的 即 len(buckets) == 2 ^ B</span></span><br><span class="line">noverflow <span class="type">uint16</span>    </span><br><span class="line">hash0     <span class="type">uint32</span>    <span class="comment">// hash0 是哈希的种子，为hash函数带来随机性</span></span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer       <span class="comment">// 当前桶的指针</span></span><br><span class="line">oldbuckets unsafe.Pointer       <span class="comment">// 扩容前保存的buckets字段</span></span><br><span class="line">nevacuate  <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line">extra *mapextra</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">overflow    *[]*bmap</span><br><span class="line">oldoverflow *[]*bmap</span><br><span class="line">nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以一个hmap的结构如下</p><p><img src="https://s2.loli.net/2023/10/16/uxlRmjYQFt8JToc.png" alt="hmap结构"></p><p>主要注意的是绿色部分，它表示桶的数组指针部分。bucket的结构又是什么样的呢？</p><p>bucket的主要由<code>bmap</code>结构体实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bmap的相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">evacuated</span><span class="params">(b *bmap)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">h := b.tophash[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">return</span> h &gt; emptyOne &amp;&amp; h &lt; minTopHash</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> overflow(t *maptype) *bmap &#123;</span><br><span class="line"><span class="keyword">return</span> *(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-goarch.PtrSize))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> setoverflow(t *maptype, ovf *bmap) &#123;</span><br><span class="line">*(**bmap)(add(unsafe.Pointer(b), <span class="type">uintptr</span>(t.bucketsize)-goarch.PtrSize)) = ovf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *bmap)</span></span> keys() unsafe.Pointer &#123;</span><br><span class="line"><span class="keyword">return</span> add(unsafe.Pointer(b), dataOffset)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里unsafe.Pointer可以理解为一个指针数组，add就类似于append，类似一个操作指针的过程，只不过都是封装好的</p><p>这段可以抽象成这样一个图</p><p><img src="https://s2.loli.net/2023/10/16/p6KieT3J9Wjkmhy.png" alt="bucket结构"></p><p>这里key和value分开放是因为key和value的类型往往是不同的，所以分开放防止padding导致内存增大</p><p>那知道这两个结构了，它内部真实的使用的整体关系是什么呢？</p><p><img src="https://s2.loli.net/2023/10/16/nukTtmqfAhDzpIW.png" alt="map整体结构"></p><p>低八位查找桶，高八位查找key</p><h3 id="Map扩容实现"><a href="#Map扩容实现" class="headerlink" title="Map扩容实现"></a>Map扩容实现</h3><p>在<code>runtime.map.go</code>中详细的写了各种情况的扩容情况</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Picking loadFactor: too large and we have lots of overflow</span></span><br><span class="line"><span class="comment">// buckets, too small and we waste a lot of space. I wrote</span></span><br><span class="line"><span class="comment">// a simple program to check some stats for different loads:</span></span><br><span class="line"><span class="comment">// (64-bit, 8 byte keys and elems)</span></span><br><span class="line"><span class="comment">//  loadFactor    %overflow  bytes/entry     hitprobe    missprobe</span></span><br><span class="line"><span class="comment">//        4.00         2.13        20.77         3.00         4.00</span></span><br><span class="line"><span class="comment">//        4.50         4.05        17.30         3.25         4.50</span></span><br><span class="line"><span class="comment">//        5.00         6.85        14.77         3.50         5.00</span></span><br><span class="line"><span class="comment">//        5.50        10.55        12.94         3.75         5.50</span></span><br><span class="line"><span class="comment">//        6.00        15.27        11.67         4.00         6.00</span></span><br><span class="line"><span class="comment">//        6.50        20.90        10.79         4.25         6.50</span></span><br><span class="line"><span class="comment">//        7.00        27.14        10.15         4.50         7.00</span></span><br><span class="line"><span class="comment">//        7.50        34.03         9.73         4.75         7.50</span></span><br><span class="line"><span class="comment">//        8.00        41.10         9.40         5.00         8.00</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// %overflow   = percentage of buckets which have an overflow bucket</span></span><br><span class="line"><span class="comment">// bytes/entry = overhead bytes used per key/elem pair</span></span><br><span class="line"><span class="comment">// hitprobe    = # of entries to check when looking up a present key</span></span><br><span class="line"><span class="comment">// missprobe   = # of entries to check when looking up an absent key</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Keep in mind this data is for maximally loaded tables, i.e. just</span></span><br><span class="line"><span class="comment">// before the table grows. Typical tables will be somewhat less loaded.</span></span><br></pre></td></tr></table></figure><p>判断扩充的条件，就是哈希表中的加载因子，加载因子是一个阈值，一般表示为：散列包含的元素数 除以 位置总数。是一种“产生冲突机会”和“空间使用”的平衡与折中：加载因子越小，说明空间空置率高，空间使用率小，但是加载因子越大，说明空间利用率上去了，但是“产生冲突机会”高了</p><p>每个哈希表都会有有一个加载因子，数值超过了加载因子就会进行扩容<br>golang的计算公式为<code>count/2^B &gt; 6.5</code> 当key和B的关系出现这种情况时或者溢出桶太多也会导致扩容，就代表需要扩容</p><p>根据触发的机制不同，也会触发两种扩容</p><h4 id="等量扩容"><a href="#等量扩容" class="headerlink" title="等量扩容"></a>等量扩容</h4><p>这种是因为大量删除导致，溢出桶过多，每个桶的实际使用没有达到，这个时候就需要通过等量扩容&#x2F;缩容去重新整理一下数据，使溢出桶中的数据重新紧凑的放在普通的bucket桶中，避免不必要的空间浪费</p><h4 id="渐进式扩容"><a href="#渐进式扩容" class="headerlink" title="渐进式扩容"></a>渐进式扩容</h4><p>这种是因为超过了加载因子，创建了一个新的桶指针数组，但是在迁移过程中如何一次性迁移，一是会造成很大CPU占用，而是需要进行大量的垃圾清除。因此Go采用渐进式的数据迁移，每次最多迁移两个bucket的数据到新的buckets中（一个是当前访问key所在的bucket，然后再多迁移一个bucket）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h2&gt;&lt;p&gt;Map在面试中被问到的东西挺多的，常见的就有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;map并发安全&lt;/li&gt;
&lt;li&gt;map底层实现&lt;/li&gt;
</summary>
      
    
    
    
    <category term="八股" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="Golang" scheme="http://xiaoheinotes.com/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>面试重点：系统调度算法</title>
    <link href="http://xiaoheinotes.com/2023/10/16/keypoint-scheduling-algorithm/"/>
    <id>http://xiaoheinotes.com/2023/10/16/keypoint-scheduling-algorithm/</id>
    <published>2023-10-16T02:03:03.000Z</published>
    <updated>2023-10-16T10:41:23.025Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考<a href="https://xiaolincoding.com/os/5_schedule/schedule.html#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95">小林coding</a></p><p>操作系统存在三大调度</p><ul><li>进程调度：对于CPU使用的调度</li><li>页面置换：对于虚拟内存的调度</li><li>磁盘调度：对于硬盘的调度</li></ul><p>对进程调度做一个大致的总结</p><h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>对CPU的调度，解决问题的出发点是如何最好的任务的执行时间和等待时间</p><h3 id="先来先服务调度算法"><a href="#先来先服务调度算法" class="headerlink" title="先来先服务调度算法"></a>先来先服务调度算法</h3><p>最简单的一个调度算法，非抢占的先来先服务算法。</p><p>依照队列排序的顺序，先来就先服务。但是这个时候会出现一个问题，就是长作业会占用CPU较长的时间，而导致后面短作业的等待时间会很长</p><p>基于这种缺点，于是最短作业优先调度就被提出来了</p><h3 id="最短作业优先调度算法"><a href="#最短作业优先调度算法" class="headerlink" title="最短作业优先调度算法"></a>最短作业优先调度算法</h3><p>最短作业调度算法是一种典型的贪心算法，它会优先选择运行时间最短的进程来运行，提高系统的吞吐量</p><p>缺点也显而易见，就是对长作业会形成一个饥饿现象，极端情况下，大量繁琐且不重要的短作业会导致长作业无法被CPU调度</p><p>可以看到两者都没法很好的去平衡短作业和长作业之间的关系</p><h3 id="高响应比优先调度算法"><a href="#高响应比优先调度算法" class="headerlink" title="高响应比优先调度算法"></a>高响应比优先调度算法</h3><p>为了权衡短作业和长作业之间的调度问题，提出了高相应比优先调度算法，其主要基于一个等待时间和要求服务时间的计算得出一个优先权，通过优先权下一个调度的对象</p><p><img src="https://s2.loli.net/2023/10/16/ZcCNF953bx1z8su.png" alt="高响应比优先调度算法"></p><h3 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h3><p>当然除了非抢占式，还存在并发系统中的时间片轮转调度算法，每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。</p><ul><li>如果时间运行结束那么将会把此进程从CPU中释放出来，并把CPU分配到另外一个进程</li><li>如果出现阻塞或结束，则马上进行切换</li></ul><p><img src="https://s2.loli.net/2023/10/16/QIoYVmw3DhPt4OK.png" alt="时间片轮转"></p><p>对于运行时间的设置也是一个关键问题</p><ul><li>时间片设置过长，退化成先来先服务调度算法</li><li>时间片设置过短，导致CPU执行过多的进程上下文切换，降低了CPU效率</li></ul><p>通常设置一个<code>20ms-50ms</code>的值是一个合理的折中值</p><h3 id="最高优先级调度算法"><a href="#最高优先级调度算法" class="headerlink" title="最高优先级调度算法"></a>最高优先级调度算法</h3><p>时间片轮转调度算法，认为所有的进程的分配时间片应该是相同。但是在实际操作系统，某些进程应该被分配更多的时间片。因为其进程往往是最重要的</p><p>进程的优先级可以分为，静态优先级或动态优先级</p><ul><li>静态优先级：创建进程时，就已经确定了优先级了，然后整个运行时间优先级都不会变化。</li><li>动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。</li></ul><p>同时该算法也有两种处理高优先级的方法，非抢占式与抢占式</p><ul><li>非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程</li><li>抢占式：就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程去运行</li></ul><p>但这样也是有缺点的，即低优先级的进程运行的概率很小</p><h3 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h3><p>对于时间片和最高优先级两种调度算法都有自己的问题</p><ul><li>时间片轮转太过于公平，以至于没有了优先级</li><li>最高优先级又矫枉过正，导致低优先级运行概率小，甚至极端情况会出现不运行的情况</li></ul><p>所以综合两者的问题，提出了多级反馈队列调度算法，其核心要点主要是两个：多级、反馈</p><ul><li>多级：即有多个队列，每个队列的优先级不同，同时优先级越高时间片越短</li><li>反馈：如果有新的进程加入优先级高的队列，立刻停止当前正在运行的进程，转而去运行优先级高的队列</li></ul><p><img src="https://s2.loli.net/2023/10/16/HwRdFW7forJek1Y.png" alt="多级反馈队列"></p><p>它的运行流程是这样的，新进程刚进来是优先最高，时间片最短的。每一次获取时间片结束后都会使他进入下一个优先级低的队列，但是时间片也会被增长。所以该算法很好的<strong>兼顾了长短作业，同时有较好的响应时间</strong></p><h2 id="内存置换算法"><a href="#内存置换算法" class="headerlink" title="内存置换算法"></a>内存置换算法</h2><p>内存置换算法是一个常考点，它主要服务于操作系统中，因为物理内存与硬盘的映射关系存在一定的大小，当CPU访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存中。与一般的中断区别是：</p><ul><li>缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完成后检查和处理中断信号</li><li>缺页中断在返回回去仍然执行该指令，其他中断则是在指向下一指令</li></ul><p>其流程如下：</p><p><img src="https://s2.loli.net/2023/10/16/Y3bU4NxeIknfljv.png" alt="内存置换算法"></p><ol><li>Load指令去查找页表</li><li>页表状态位为无效的，触发中断请求</li><li>操作系统查找磁盘对应页面位置</li><li>加载到物理内存中</li><li>修改页表项的状态位</li><li>重新执行导致异常的指令</li></ol><h3 id="最佳页面置换算法-OPT"><a href="#最佳页面置换算法-OPT" class="headerlink" title="最佳页面置换算法(OPT)"></a>最佳页面置换算法(OPT)</h3><p>最佳页面置换算法的思路，就是替换掉未来最长时间不访问的页面，但是操作系统往往不知道未来访问的情况，所以这个算法是没法实现的</p><h3 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h3><p>先进先出就用了一个队列进行模拟，队尾是新的，队头是要被清除的，通常的实现方法是<strong>链表实现</strong></p><h3 id="最近最久未使用-LRU"><a href="#最近最久未使用-LRU" class="headerlink" title="最近最久未使用 LRU"></a>最近最久未使用 LRU</h3><p>删除掉最进最久为使用的，听起来貌似好像很绕，实际换种说法就很容易理解，即选中最长时间没有被访问的页面进行置换。有点类似最佳页面置换算法，但是区别在于是基于已知的页面击中情况进行处理的。</p><p><img src="https://s2.loli.net/2023/10/16/LV7NPC9aSOqucJ8.png" alt="最近最久未使用"></p><p>一般来说它的实现方法，是有一个双向链表加上一个set集合实现。实现的代价是比较大的。队头代表最新访问，队尾代表最久未被访问</p><h3 id="时钟页面置换算法"><a href="#时钟页面置换算法" class="headerlink" title="时钟页面置换算法"></a>时钟页面置换算法</h3><p>那有没有一种即能优化置换的次数，也能方便实现的算法呢？</p><p>时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。</p><p>该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。</p><h3 id="最不常用算法-LFU"><a href="#最不常用算法-LFU" class="headerlink" title="最不常用算法 LFU"></a>最不常用算法 LFU</h3><p>最不常用算法指的发送页面中断时，清除掉访问次数最小的那个页面</p><p>LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。</p><h2 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h2><p>机械硬盘是转盘的结构，像唱片一样的指针去查询磁盘。磁盘调度算法是要做什么呢？</p><p>当系统请求访问如下序列：</p><p>98，183，37，122，14，124，65，67</p><p>初始磁头在某个位置，需要一个算法来调度指针去按一定的顺序查找</p><h3 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h3><p>最简单也是最容易想到的，直接按照序列读写</p><h3 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h3><p>典型的贪心算法，每次找队列中离自己指针距离最近的一个，但是这种算法可能会存在饥饿现象，如果是动态的序列，新来的总是最近的，会导致旧的无法被读取到</p><h3 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h3><p>磁头在一个方向上移动，访问所有未完成的请求，直到磁头到达该方向上的最后磁道，才调换方向，这就是扫描算法</p><p>扫描调度算法性能较好，不会产生饥饿现象，但是存在这样的问题，中间部分的磁道会比较占便宜，中间部分相比其他部分响应的频率会比较多，也就是说每个磁道的响应频率存在差异。</p><h3 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h3><p>如果说扫描算法存在磁道的响应频率差异，那么公平点，就直接单向扫描呗</p><p>循环扫描（Circular Scan, CSCAN ）规定：只有磁头朝某个特定方向移动时，才处理磁道访问请求，而返回时直接快速移动至最靠边缘的磁道，也就是复位磁头，这个过程是很快的，并且返回中途不处理任何请求，该算法的特点，就是磁道只响应一个方向上的请求。</p><h3 id="LOOK-与-C-LOOK算法"><a href="#LOOK-与-C-LOOK算法" class="headerlink" title="LOOK 与 C-LOOK算法"></a>LOOK 与 C-LOOK算法</h3><p>相信大家在看到扫描算法和循环扫描算法都会疑惑， 为什么指针一定要到边界才能反向呢。有点算法基础的同学肯定马上想到了，通过两个最大最小值，去确定实际要扫描的区间范围，而不需要去移动到磁盘的最始端或最末端，反向移动的途中会响应请求</p><p>所以LOOK算法是针对扫描算法进行的优化，确定区间范围，只在指定范围移动即可</p><p>C-LOOK算法则是针对循环扫描算法进行的优化，和LOOK算法思想类似，不过是单向的扫描</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要参考&lt;a href=&quot;https://xiaolincoding.com/os/5_schedule/schedule.html#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%B</summary>
      
    
    
    
    <category term="八股" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="调度算法" scheme="http://xiaoheinotes.com/tags/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>笔试记录：亚信安全</title>
    <link href="http://xiaoheinotes.com/2023/10/15/exam-yaxinanquan/"/>
    <id>http://xiaoheinotes.com/2023/10/15/exam-yaxinanquan/</id>
    <published>2023-10-15T12:26:14.000Z</published>
    <updated>2023-10-16T01:40:41.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出"><a href="#把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出" class="headerlink" title="把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出"></a>把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> input <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">n := <span class="built_in">len</span>(input)</span><br><span class="line">nums1 := hexToInt(input[n<span class="number">-2</span>:])</span><br><span class="line">nums2 := hexToInt(input[n<span class="number">-4</span> : n<span class="number">-2</span>])</span><br><span class="line">nums3 := hexToInt(input[n<span class="number">-6</span> : n<span class="number">-4</span>])</span><br><span class="line">nums4 := hexToInt(input[n<span class="number">-8</span> : n<span class="number">-6</span>])</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v.%v.%v.%v&quot;</span>, nums1, nums2, nums3, nums4)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hexToInt</span><span class="params">(hex <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">num, _ := strconv.ParseInt(hex, <span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="type">int</span>(num)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="验证括号组成的字符串是否正常"><a href="#验证括号组成的字符串是否正常" class="headerlink" title="验证括号组成的字符串是否正常"></a>验证括号组成的字符串是否正常</h2><p>leetcode 原题：<a href="https://leetcode.cn/problems/valid-parentheses/">有效括号</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> input <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;input)</span><br><span class="line">fmt.Println(isValid(input))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isValid</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">n := <span class="built_in">len</span>(s)</span><br><span class="line"><span class="keyword">if</span> n%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">set := <span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">byte</span>&#123;</span><br><span class="line"><span class="string">&#x27;)&#x27;</span>: <span class="string">&#x27;(&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;]&#x27;</span>: <span class="string">&#x27;[&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>: <span class="string">&#x27;&#123;&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack := []<span class="type">byte</span>&#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">if</span> set[s[i]] &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(stack) == <span class="number">0</span> || stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] != set[s[i]] &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">stack = <span class="built_in">append</span>(stack, s[i])</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="求两个ip地址的最大相同前缀"><a href="#求两个ip地址的最大相同前缀" class="headerlink" title="求两个ip地址的最大相同前缀"></a>求两个ip地址的最大相同前缀</h2><p>输入</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.1.1 192.168.1.3</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Prefix length:  30</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ip1, ip2 <span class="type">string</span></span><br><span class="line">fmt.Scanln(&amp;ip1, &amp;ip2)</span><br><span class="line">ip1Byte := ipTobit(ip1)</span><br><span class="line">ip2Byte := ipTobit(ip2)</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ip1Byte); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> ip1Byte[i] != ip2Byte[i] &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sum++</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Prefix length:&quot;</span>, sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ipTobit</span><span class="params">(ip <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">32</span>)</span><br><span class="line">ipStr := strings.Split(ip, <span class="string">&quot;.&quot;</span>)</span><br><span class="line">ipNum := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(ipStr))</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ipStr); i++ &#123;</span><br><span class="line">ipNum[i], _ = strconv.Atoi(ipStr[i])</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ipNum); i++ &#123;</span><br><span class="line">binaryStr := intTobin(ipNum[i])</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="built_in">len</span>(binaryStr); j++ &#123;</span><br><span class="line">res[i*<span class="number">8</span>+j] = binaryStr[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intTobin</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">binaryStr := strconv.FormatInt(<span class="type">int64</span>(num), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">len</span>(binaryStr) &lt; <span class="number">8</span> &#123;</span><br><span class="line">binaryStr = <span class="string">&quot;0&quot;</span> + binaryStr</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> binaryStr</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出&quot;&gt;&lt;a href=&quot;#把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输出&quot; class=&quot;headerlink&quot; title=&quot;把小端字节序的IPv4地址转换成大端字节序表示，并用点分法输</summary>
      
    
    
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试经验：好未来凉经</title>
    <link href="http://xiaoheinotes.com/2023/10/15/interview-experience-tal/"/>
    <id>http://xiaoheinotes.com/2023/10/15/interview-experience-tal/</id>
    <published>2023-10-15T08:42:29.000Z</published>
    <updated>2023-10-16T01:40:41.939Z</updated>
    
    <content type="html"><![CDATA[<p>2023年10月15日面试凉经，全程面试官表现真的很无语，一直问：还有呢？继续介绍。感觉好像是因为我的关系让他加班一样。全程不引导，不讨论，就是继续继续。</p><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>按照以往流程背诵</p><h2 id="介绍一下项目"><a href="#介绍一下项目" class="headerlink" title="介绍一下项目"></a>介绍一下项目</h2><p>简单说了一下项目亮点。回复我就这些？让我继续说，我说就是这些。然后他又说挑一个亮点说。我说了一个双Token续约。继续挖</p><h3 id="双Token怎么续约的？"><a href="#双Token怎么续约的？" class="headerlink" title="双Token怎么续约的？"></a>双Token怎么续约的？</h3><h3 id="双Token怎么保证安全性的？"><a href="#双Token怎么保证安全性的？" class="headerlink" title="双Token怎么保证安全性的？"></a>双Token怎么保证安全性的？</h3><p>我说只能说是相对的一点保证，减低获取Token的难度，并且优化用户的续约体验</p><h3 id="双Token怎么续约的"><a href="#双Token怎么续约的" class="headerlink" title="双Token怎么续约的"></a>双Token怎么续约的</h3><p>AccessToken做短期续约，保证安全<br>RefreshToken做长期续约，保证用户的体验</p><h3 id="和单Token有什么区别？"><a href="#和单Token有什么区别？" class="headerlink" title="和单Token有什么区别？"></a>和单Token有什么区别？</h3><p>全程觉得这种优化没用。服了</p><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="操作系统缓存有哪些？"><a href="#操作系统缓存有哪些？" class="headerlink" title="操作系统缓存有哪些？"></a>操作系统缓存有哪些？</h3><p>讲真我第一次听，真不知道他在说啥，我想了一下关于缓存调度的东西，没想到。但是想了一下常问的内存页面置换，就问他一下是不是这个，还真是，笑死。</p><ul><li>最佳页面置换 OPT</li><li>先进先出置换 FIFO</li><li>最久未使用  LRU</li><li>时钟页面置换  </li><li>最不常用算法 LFU</li></ul><h3 id="内存页面置换算法的极限命中率？"><a href="#内存页面置换算法的极限命中率？" class="headerlink" title="内存页面置换算法的极限命中率？"></a>内存页面置换算法的极限命中率？</h3><p>讲真不知道这个问的是啥</p><h3 id="进程调度算法有哪些？"><a href="#进程调度算法有哪些？" class="headerlink" title="进程调度算法有哪些？"></a>进程调度算法有哪些？</h3><ul><li>先来先服务</li><li>最短作业优先</li><li>高响应比优先调度</li><li>时间片轮转调度算法</li><li>最高优先级调度算法</li><li>多级反馈队列调度算法</li></ul><h3 id="除了多级反馈队列调度算法，上面那个最好？"><a href="#除了多级反馈队列调度算法，上面那个最好？" class="headerlink" title="除了多级反馈队列调度算法，上面那个最好？"></a>除了多级反馈队列调度算法，上面那个最好？</h3><p>上来就问最好，还是排除掉目前主流的问最好。</p><h3 id="B-树的插入时间复杂度"><a href="#B-树的插入时间复杂度" class="headerlink" title="B+树的插入时间复杂度"></a>B+树的插入时间复杂度</h3><p>不知道，当场推成logm(n)，m是树的度，n是总数</p><h3 id="TCP有哪些缺点？"><a href="#TCP有哪些缺点？" class="headerlink" title="TCP有哪些缺点？"></a>TCP有哪些缺点？</h3><ul><li>可能粘包</li><li>队头阻塞</li><li>建立连接需要时间长</li><li>网络迁移需要重新建立 TCP 连接</li></ul><h2 id="手撕快排"><a href="#手撕快排" class="headerlink" title="手撕快排"></a>手撕快排</h2><p>四分钟写完。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>挺恶心的，最恶心的一次面试了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年10月15日面试凉经，全程面试官表现真的很无语，一直问：还有呢？继续介绍。感觉好像是因为我的关系让他加班一样。全程不引导，不讨论，就是继续继续。&lt;/p&gt;
&lt;h2 id=&quot;自我介绍&quot;&gt;&lt;a href=&quot;#自我介绍&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试经验：中国电子云后端开发</title>
    <link href="http://xiaoheinotes.com/2023/10/13/interview-experience-cecloud/"/>
    <id>http://xiaoheinotes.com/2023/10/13/interview-experience-cecloud/</id>
    <published>2023-10-13T09:15:06.000Z</published>
    <updated>2023-10-13T12:24:36.468Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下2023年10月13日中国电子云一面流程，整体流程很快，自我介绍，挖实习挖项目，问了一点点八股，然后就是反问环节，正式面试的时候整个流程17min，有点KPI的意思，反问的时候和面试官聊了很多，面试官人挺好的讲的很清楚。</p><h2 id="从个人性格、学校经历、实习经历三个点进行自我介绍"><a href="#从个人性格、学校经历、实习经历三个点进行自我介绍" class="headerlink" title="从个人性格、学校经历、实习经历三个点进行自我介绍"></a>从个人性格、学校经历、实习经历三个点进行自我介绍</h2><p>我听得完直接按照自己之前背的个人介绍说了出来</p><h2 id="挖实习"><a href="#挖实习" class="headerlink" title="挖实习"></a>挖实习</h2><h3 id="从什么角度去考虑重构的"><a href="#从什么角度去考虑重构的" class="headerlink" title="从什么角度去考虑重构的"></a>从什么角度去考虑重构的</h3><p>单体服务转到微服务上去</p><h3 id="OCR实现流程的"><a href="#OCR实现流程的" class="headerlink" title="OCR实现流程的"></a>OCR实现流程的</h3><p>简单的API调用，然后就说了其他的点</p><h3 id="还有什么商业模型？"><a href="#还有什么商业模型？" class="headerlink" title="还有什么商业模型？"></a>还有什么商业模型？</h3><p>无，感觉面试官对实习做的东西不是很满意</p><h2 id="挖项目"><a href="#挖项目" class="headerlink" title="挖项目"></a>挖项目</h2><h3 id="双token-怎么实现的，为什么要双Token？"><a href="#双token-怎么实现的，为什么要双Token？" class="headerlink" title="双token 怎么实现的，为什么要双Token？"></a>双token 怎么实现的，为什么要双Token？</h3><p>双Token是AccessToken和RefreshToken两个token，通过两个token分别记录</p><h3 id="gin框架怎么使用的获取这两个token"><a href="#gin框架怎么使用的获取这两个token" class="headerlink" title="gin框架怎么使用的获取这两个token"></a>gin框架怎么使用的获取这两个token</h3><p>通过中间件拦截，在中间件里的c.getHeader获取的</p><h3 id="怎么保证安全性的？"><a href="#怎么保证安全性的？" class="headerlink" title="怎么保证安全性的？"></a>怎么保证安全性的？</h3><p>安全性并不能绝对的保证，但是可以让他更安全。需要获取两个AccessToken和RefreshToken。AccessToken的过期时间短，RefreshToken的过期时间更长。<br>假设有人偷取了我的两个Token，但是RefreshToken的自动刷新也会</p><h3 id="和单Token续约不行吗？"><a href="#和单Token续约不行吗？" class="headerlink" title="和单Token续约不行吗？"></a>和单Token续约不行吗？</h3><p>单Token续约存在一些问题，因为实际上的业务存在两种Token续约的情况，一个是用户不断的点击去续约Token，但是还有一种情况比如说用户一天内没有登录，或者一段时间没有操作。那这时候单Token就会有一些尬尴的处境</p><ul><li>过期时间设置过长，会导致token无法保证安全性</li><li>过期时间设置过短，会导致token过期，导致用户长时间不操作需要频繁的去进行登录</li></ul><h2 id="八股"><a href="#八股" class="headerlink" title="八股"></a>八股</h2><h3 id="channel底层怎么实现的？"><a href="#channel底层怎么实现的？" class="headerlink" title="channel底层怎么实现的？"></a>channel底层怎么实现的？</h3><p>如下是channel的底层代码，可以看到它是一个<code>hchan</code>结构体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">    qcount   <span class="type">uint</span>           <span class="comment">// 队列中的数据个数</span></span><br><span class="line">    dataqsiz <span class="type">uint</span>           <span class="comment">// 环形队列的大小，channel本身是一个环形队列</span></span><br><span class="line">    buf      unsafe.Pointer <span class="comment">// 存放实际数据的指针，用unsafe.Pointer存放地址，为了避免gc</span></span><br><span class="line">    elemsize <span class="type">uint16</span> </span><br><span class="line">    closed   <span class="type">uint32</span> <span class="comment">// 标识channel是否关闭</span></span><br><span class="line">    elemtype *_type <span class="comment">// 数据 元素类型</span></span><br><span class="line">    sendx    <span class="type">uint</span>   <span class="comment">// send的 index</span></span><br><span class="line">    recvx    <span class="type">uint</span>   <span class="comment">// recv 的 index</span></span><br><span class="line">    recvq    waitq  <span class="comment">// 阻塞在 recv 的队列</span></span><br><span class="line">    sendq    waitq  <span class="comment">// 阻塞在 send 的队列</span></span><br><span class="line"></span><br><span class="line">    lock mutex  <span class="comment">// 锁 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的用一个图去解释这<code>hchan</code>的主要参数的关系</p><p><img src="https://s2.loli.net/2023/10/13/fqWkzD4RJXP8CYa.png" alt="channel底层"></p><p>主要的是一个环形队列，去保存传输的缓存数据</p><p><code>sendx</code>和<code>recvx</code>表示这两个环形队列的位置<br><code>recvq</code>和<code>sendq</code>表示两个等待队列的当前指针</p><h3 id="两个协程之间如何通信？"><a href="#两个协程之间如何通信？" class="headerlink" title="两个协程之间如何通信？"></a>两个协程之间如何通信？</h3><p>平时写的时候是使用channel进行通信。通过make创建对应类型的channel进行通信</p><h3 id="GMP调度怎么实现的"><a href="#GMP调度怎么实现的" class="headerlink" title="GMP调度怎么实现的"></a>GMP调度怎么实现的</h3><p>基本的</p><ul><li>G Goroutine 的缩写，每次 go func() 都代表一个 G，无限制，但受内存影响。使用 struct runtime.g，包含了当前 goroutine 的状态、堆栈、上下文</li><li>M 工作线程(OS thread)也被称为 Machine，使用 struct runtime.m，所有 M 是有线程栈的。M 的默认数量限制是 10000（来源），可以通过debug.SetMaxThreads修改。</li><li>P Processor，是一个抽象的概念，并不是真正的物理 CPU，P 表示执行 Go 代码所需的资源，可以通过 GOMAXPROCS 进行修改。当 M 执行 Go 代码时，会先关联 P。当 M 空闲或者处在系统调用时，就需要 P</li></ul><p>这个博客里讲的很好，之前也是看着这个理解GMP的调度。可以参考一下<a href="https://blog.csdn.net/xmcy001122/article/details/119392934">GMP调度模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;记录一下2023年10月13日中国电子云一面流程，整体流程很快，自我介绍，挖实习挖项目，问了一点点八股，然后就是反问环节，正式面试的时候整个流程17min，有点KPI的意思，反问的时候和面试官聊了很多，面试官人挺好的讲的很清楚。&lt;/p&gt;
&lt;h2 id=&quot;从个人性格、学校经历</summary>
      
    
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
  </entry>
  
  <entry>
    <title>面试重点：k8s相关面试题</title>
    <link href="http://xiaoheinotes.com/2023/10/12/interview-k8s-key-point/"/>
    <id>http://xiaoheinotes.com/2023/10/12/interview-k8s-key-point/</id>
    <published>2023-10-12T03:23:56.000Z</published>
    <updated>2023-10-12T09:24:07.091Z</updated>
    
    <content type="html"><![CDATA[<p>学习K8S前建议先学习过docker或者快速阅读一下这篇文章<img src="http://xiaoheinotes.com/2023/10/07/interview-docker-key-point/" alt="Docker面试总结"></p><h2 id="K8S-是什么？"><a href="#K8S-是什么？" class="headerlink" title="K8S 是什么？"></a>K8S 是什么？</h2><p>Kubernetes是一个容器编排平台，用于自动化容器化应用程序的部署、扩展、管理和维护。Kubernetes提供了负载均衡、自动伸缩、服务发现等功能，以便有效地管理大规模的容器部署。基本是云厂商不可或缺的一个工具了</p><h2 id="Docker和K8S的关系是什么？"><a href="#Docker和K8S的关系是什么？" class="headerlink" title="Docker和K8S的关系是什么？"></a>Docker和K8S的关系是什么？</h2><p>Docker和K8S之间是一种协同的关系，Docker负责应用级的容器构建、打包，K8S负责容器编排和容器管理</p><h3 id="Docker：容器化平台"><a href="#Docker：容器化平台" class="headerlink" title="Docker：容器化平台"></a>Docker：容器化平台</h3><ul><li>容器引擎：通过Docker Engine实现容器的构建、打包、运行。提供容器的生命周期</li><li>容器镜像：通过容器镜像实现沙箱化模式，让容器可以轻松的在不同环境下部署</li></ul><h3 id="K8S-容器管理平台"><a href="#K8S-容器管理平台" class="headerlink" title="K8S 容器管理平台"></a>K8S 容器管理平台</h3><ul><li>部署与管理容器：Kubernetes 可以自动化地管理和编排容器的部署、伸缩和更新，确保应用程序高可用性和可伸缩性。</li><li>服务编排：Kubernetes可以定义、部署和管理多个容器的组合，以构建复杂的应用程序。</li><li>资源管理：Kubernetes可以有效地管理计算、存储和网络资源，以满足应用程序的需求。</li><li>自动运维：Kubernetes支持自动化的容器部署、恢复、扩展和滚动升级。</li></ul><h2 id="主机上部署和容器上部署有什么区别吗？"><a href="#主机上部署和容器上部署有什么区别吗？" class="headerlink" title="主机上部署和容器上部署有什么区别吗？"></a>主机上部署和容器上部署有什么区别吗？</h2><p><img src="https://s2.loli.net/2023/10/12/ZTovOg6XGRcmsx9.png" alt="主机与容器部署的区别"></p><h3 id="结构区别"><a href="#结构区别" class="headerlink" title="结构区别"></a>结构区别</h3><p>首先最明显的就是隔离性的区别</p><p>左侧架构表示用主机直接部署的老方法，所有的应用程序依赖都基于主机的一个软件库。</p><p>右侧架构即是容器架构，容器架构将有一个内核，这是所有应用程序唯一共享的底层。每个应用程序的底层都是自己独立的软件库，保证了每个应用程序的隔离性</p><h3 id="部署速度"><a href="#部署速度" class="headerlink" title="部署速度"></a>部署速度</h3><p>主机直接部署需要先安装各个应用程序所需要的依赖。导致安装更复杂，部署困难问题</p><p>容器部署 则不需要考虑这么多，只需要构建对应的镜像即可</p><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><p>主机部署模式下，应用程序如果想切换主机，就需要重新去部署。甚至还可能会遇到版本不同步的问题</p><p>容器部署模式下，通过打包，将应用程序和依赖封装在一个标准化的容器中，可以在不同环境进行运行</p><h2 id="什么是容器编排（Container-Orchestration）？"><a href="#什么是容器编排（Container-Orchestration）？" class="headerlink" title="什么是容器编排（Container Orchestration）？"></a>什么是容器编排（Container Orchestration）？</h2><p>虽然容器有很多好处，但是有一个缺点，就是微服务的情况下，容器是相互独立。这就意味着容器之间无法去进行通信。为了解决这个问题？</p><p>于是在上层即K8S实现容器的编排，即一种管理和协调容器化应用程序的自动化过程。</p><p>通过这种手段的实现，最后实现整个微服务构建的容器之间的互相通信问题。同时还可以实现一些功能性的组件并实现容器的日志监控</p><h2 id="K8S-有什么特点"><a href="#K8S-有什么特点" class="headerlink" title="K8S 有什么特点"></a>K8S 有什么特点</h2><ul><li>自动化编排：Kubernetes能够自动化容器的部署、伸缩、升级和维护，大大减少了运维负担。</li><li>容器抽象：Kubernetes引入了容器抽象，容器化的应用程序在K8s中被视为一个单一的实体，从而简化了管理和操作。</li><li>自我修复：K8s能够自动检测和恢复故障容器、节点或整个集群，确保应用程序的高可用性。</li><li>负载均衡：Kubernetes支持负载均衡，可以将流量均匀分布到容器实例之间，提高应用程序的可伸缩性和性能。</li><li>自动伸缩：K8s允许根据负载自动扩展或缩减容器实例的数量，以满足应用程序的需求。</li><li>容器网络：Kubernetes提供容器之间的通信和网络隔离，允许容器安全地互相通信。</li><li>配置管理：Kubernetes支持配置管理，容器的配置和环境变量可以在部署期间灵活配置。</li></ul><p>看着好像是一长串，但实际上这些特点都是有迹可循的</p><p>首先自动化编排不用说，K8S的核心要素。自动化编排去编排什么？ 抽象的实例，用<strong>容器</strong>去实现。既然K8S已经可以实现容器的编排了。那如果容器进程崩溃要怎么办，这时就需要K8S去进行重启。这就是<strong>自我修复</strong>功能。但是我们直到微服务往往是集群模式，所以可扩展也是必须要求的，所以就可以进行<strong>自动伸缩</strong>允许我们去控制实例的重复数量。既然微服务有集群模式，那是不是要进行负载均衡去解决这个问题。所以K8S也有<strong>负载均衡</strong>的作用。最后就是统一配置了通过K8S的编排，可以配置容器内部的环境变量，这样在容器部署期间就可以灵活的<strong>配置</strong></p><h2 id="K8S架构是什么样的？"><a href="#K8S架构是什么样的？" class="headerlink" title="K8S架构是什么样的？"></a>K8S架构是什么样的？</h2><p>和大多数分布式系统一样，K8S集群至少需要一个主节点（Master）和多个计算节点（Node）</p><ul><li>主节点主要用于暴露API，调度部署和节点的管理</li><li>计算节点运行一个容器运行环境，同时运行一个K8s的代理（kubelet）用于和master通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是k8s集群中真正工作的节点。</li></ul><h3 id="Master节点"><a href="#Master节点" class="headerlink" title="Master节点"></a>Master节点</h3><ul><li>Kubectl：客户端命令行工具，作为整个K8s集群的操作入口</li><li>Api Server：在K8s架构中承担的是“桥梁”的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API注册和发现等机制。客户端与k8s群集及K8s内部组件的通信，都要通过Api Server这个组件</li><li>Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等</li><li>Scheduler：负责资源的调度，按照预定的调度策略将pod调度到相应的node节点上</li><li>Etcd：担任数据中心的角色，保存了整个群集的状态</li></ul><h3 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h3><ul><li>Kubelet：负责维护容器的生命周期，同时也负责Volume和网络的管理，一般运行在所有的节点，是Node节点的代理，当Scheduler确定某个node上运行pod之后，会将pod的具体信息（image，volume）等发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向master返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该pod杀死，然后重新创建一个容器</li><li>Kube-proxy：Service在逻辑上代表了后端的多个pod。负责为Service提供cluster内部的服务发现和负载均衡（外界通过Service访问pod提供的服务时，Service接收到的请求后就是通过kube-proxy来转发到pod上的）</li><li>container-runtime：是负责管理运行容器的软件，比如docker</li><li>Pod：是k8s集群里面最小的单位。每个pod里边可以运行一个或多个container（容器），如果一个pod中有两个container，那么container的USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。我比较喜欢把pod来当做豌豆夹，而豌豆就是pod中的container</li></ul><h2 id="kubenetes针对pod资源对象的健康监测机制？"><a href="#kubenetes针对pod资源对象的健康监测机制？" class="headerlink" title="kubenetes针对pod资源对象的健康监测机制？"></a>kubenetes针对pod资源对象的健康监测机制？</h2><ul><li>livenessProbe探针</li></ul><p>可以根据用户自定义规则来判定pod是否健康，如果livenessProbe探针探测到容器不健康，则kubelet会根据其重启策略来决定是否重启，如果一个容器不包含livenessProbe探针，则kubelet会认为容器的livenessProbe探针的返回值永远成功。</p><ul><li>ReadinessProbe探针</li></ul><p>同样是可以根据用户自定义规则来判断pod是否健康，如果探测失败，控制器会将此pod从对应service的endpoint列表中移除，从此不再将任何请求调度到此Pod上，直到下次探测成功。</p><ul><li>startupProbe探针</li></ul><p>启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。</p><h2 id="如何控制滚动更新过程？"><a href="#如何控制滚动更新过程？" class="headerlink" title="如何控制滚动更新过程？"></a>如何控制滚动更新过程？</h2><p>此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学习K8S前建议先学习过docker或者快速阅读一下这篇文章&lt;img src=&quot;http://xiaoheinotes.com/2023/10/07/interview-docker-key-point/&quot; alt=&quot;Docker面试总结&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;K8S</summary>
      
    
    
    
    <category term="八股文" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="k8s" scheme="http://xiaoheinotes.com/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>项目总结：电子商城面试必备</title>
    <link href="http://xiaoheinotes.com/2023/10/10/project-web-mall/"/>
    <id>http://xiaoheinotes.com/2023/10/10/project-web-mall/</id>
    <published>2023-10-10T11:16:02.000Z</published>
    <updated>2023-10-15T04:23:20.004Z</updated>
    
    <content type="html"><![CDATA[<p>好久之前做的简单电子商城项目，进行一下回顾，并试着复述一下项目的难点与亮点</p><p>这里有针对这些问题的demo，<a href="https://github.com/yxh175/web-small-demo">电子商城亮点demo</a></p><h2 id="简单介绍一下你的项目的亮点和难点"><a href="#简单介绍一下你的项目的亮点和难点" class="headerlink" title="简单介绍一下你的项目的亮点和难点"></a>简单介绍一下你的项目的亮点和难点</h2><p>电子商城项目是我用go尝试开发的一个简易项目，其中项目主要用到了Gin做路由分布，Gorm做数据库查询。同时使用Redis实现一些相关功能。</p><h3 id="项目亮点"><a href="#项目亮点" class="headerlink" title="项目亮点"></a>项目亮点</h3><ul><li>权限控制及Token续约：使用Gin及jwt-token做权限拦截，并通过双token实现安全性和续期的双重保障</li><li>多级缓存：使用redis做缓存缓解数据库读写压力，同时通过合适的算法保证缓存一致性</li><li>防止超卖：使用redis做分布式锁，防止出现高并发情况下的超卖现象</li><li>ELK日志监控：通过定制化 Zap 实现多输出源，同时将日志输出到 Console （Standard IO） 与 MQ 中，再配置 Logstash Input 使其读取 MQ 中的日志并写入 ES 中，最后在 Kibana 中展示。</li></ul><h3 id="权限拦截及双Token的实现"><a href="#权限拦截及双Token的实现" class="headerlink" title="权限拦截及双Token的实现"></a>权限拦截及双Token的实现</h3><p>权限拦截主要通过Gin框架实现</p><p>通过Gin框架的中间件模式，可以实现基本的鉴权功能</p><p>路由函数可以使用<code>r.use</code>或者使用<code>r.group</code>，都可以。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 使用鉴权中间件</span></span><br><span class="line">r.Use(middleware.JWTMiddleware())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>鉴权中间件如何实现的呢？</p><p>首先先构建jwt-token结构体，然后写两个方法，一个分发，一个验证。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jwtSecret = []<span class="type">byte</span>(<span class="string">&quot;secret&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> JWTClaims <span class="keyword">struct</span> &#123;</span><br><span class="line">ID       <span class="type">uint</span>   <span class="string">`json:&quot;id&quot;`</span></span><br><span class="line">UserName <span class="type">string</span> <span class="string">`json:&quot;user_name&quot;`</span></span><br><span class="line">jwt.StandardClaims</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenerateToken 签发用户Token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateToken</span><span class="params">(id <span class="type">uint</span>, username <span class="type">string</span>)</span></span> (accessToken, refreshToken <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseToken 验证用户token</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseToken</span><span class="params">(token <span class="type">string</span>)</span></span> (*JWTClaims, <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseRefreshToken</span><span class="params">(aToken, rToken <span class="type">string</span>)</span></span> (newAToken, newRToken <span class="type">string</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用jwt-token，它的核心部分是获取token，然后对token做验证，正常就<code>c.Next()</code>放行，否则就要<code>c.Abort()</code>拦截</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">JWTMiddleware</span><span class="params">()</span></span> gin.HandlerFunc &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">code := <span class="number">200</span></span><br><span class="line">accessToken := c.GetHeader(<span class="string">&quot;access-Token&quot;</span>)</span><br><span class="line">        refreshToken := c.GetHeader(<span class="string">&quot;refresh-Token&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.检验token是否有效</span></span><br><span class="line"><span class="keyword">if</span> accessToken == <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">code = <span class="number">401</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;status&quot;</span>: code,</span><br><span class="line"><span class="string">&quot;data&quot;</span>:   <span class="string">&quot;token不能为空&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        accessClaims, err := util.ParseToken(accessToken)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">code = <span class="number">401</span></span><br><span class="line">c.JSON(<span class="number">200</span>, gin.H&#123;</span><br><span class="line"><span class="string">&quot;status&quot;</span>: code,</span><br><span class="line"><span class="string">&quot;data&quot;</span>:   <span class="string">&quot;token异常&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">c.Abort()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 2.检验accessToken是否过期</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> accessClaims.ExpiresAt &gt; time.Now().Unix() &#123;</span><br><span class="line">c.Set(<span class="string">&quot;id&quot;</span>, accessClaims.ID)</span><br><span class="line">c.Set(<span class="string">&quot;username&quot;</span>, accessClaims.UserName)</span><br><span class="line">c.Next()</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 双token续约机制</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c.Set(<span class="string">&quot;id&quot;</span>, claims.ID)</span><br><span class="line">c.Set(<span class="string">&quot;username&quot;</span>, claims.UserName)</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在运行时，可以发现token是会检验的。当accessToken过期时，会根据refreshToken情况决定是否更新Token，更新的Token返回给前端</p><h4 id="双Token的优点"><a href="#双Token的优点" class="headerlink" title="双Token的优点"></a>双Token的优点</h4><ul><li>accessToken的存在，保证了登录态的正常验证，因其过期时间的短暂也保证了帐号的安全性</li><li>refreshToken的存在，保证了用户（即使是非活跃用户）无需在短时间内进行反复的登陆操作来保证登录态的有效性，同时也保证了活跃用户的登录态可以一直存续而不需要进行重新登录，其反复刷新也防止别人获取refreshToken干坏事</li></ul><p>流程图如下</p><p><img src="https://s2.loli.net/2023/10/10/HEqg1vRsxGNJu37.png" alt="双token验证流程"></p><h4 id="无效的Token处理"><a href="#无效的Token处理" class="headerlink" title="无效的Token处理"></a>无效的Token处理</h4><p>refreshToken的无效token会生成的比较多，如何处理呢？</p><ul><li>简单的从浏览器移除</li><li>制作一个token黑名单</li></ul><h3 id="多级缓存如何实现"><a href="#多级缓存如何实现" class="headerlink" title="多级缓存如何实现"></a>多级缓存如何实现</h3><p>首先通过<code>demo.sql</code>建一个表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> SCHEMA cache_demo;</span><br><span class="line">use cache_demo;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> if <span class="keyword">exists</span> products;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> products (</span><br><span class="line">    id <span class="type">INT</span> AUTO_INCREMENT <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    p_id <span class="type">Int</span> <span class="keyword">Not</span> <span class="keyword">NULL</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    price <span class="type">DECIMAL</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    count <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>本模块在<code>cache_demo</code>中实现</p><p>首先先做好基本的DB查询。这里DB使用gorm，同时使用连接池和读写分离保证高性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _db *gorm.DB</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InitMySQL</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 假装四个读写mysql服务器，进行读写分离, 电商读多写少</span></span><br><span class="line">read1_dsn := <span class="string">&quot;root:1234@tcp(localhost:3306)/cache_demo?parseTime=true&quot;</span></span><br><span class="line">read2_dsn := <span class="string">&quot;root:1234@tcp(localhost:3306)/cache_demo?parseTime=true&quot;</span></span><br><span class="line">write1_dsn := <span class="string">&quot;root:1234@tcp(localhost:3306)/cache_demo?parseTime=true&quot;</span></span><br><span class="line">write2_dsn := <span class="string">&quot;root:1234@tcp(localhost:3306)/cache_demo?parseTime=true&quot;</span></span><br><span class="line"></span><br><span class="line">db, err := gorm.Open(mysql.Open(write1_dsn), &amp;gorm.Config&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">_db = db</span><br><span class="line">    _db.Use(</span><br><span class="line">        dbresolver.Register(dbresolver.Config&#123;</span><br><span class="line">            Sources:  []gorm.Dialector&#123;mysql.Open(write2_dsn)&#125;,</span><br><span class="line">            Replicas: []gorm.Dialector&#123;mysql.Open(read1_dsn), mysql.Open(read2_dsn)&#125;,</span><br><span class="line">            Policy:   dbresolver.RandomPolicy&#123;&#125;,</span><br><span class="line">            <span class="comment">// print sources/replicas mode in logger</span></span><br><span class="line">            TraceResolverMode: <span class="literal">true</span>,</span><br><span class="line">        &#125;).</span><br><span class="line">            SetConnMaxIdleTime(time.Hour).</span><br><span class="line">            SetConnMaxLifetime(<span class="number">24</span> * time.Hour).</span><br><span class="line">            SetMaxIdleConns(<span class="number">100</span>).</span><br><span class="line">            SetMaxOpenConns(<span class="number">200</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">_db = _db.Set(<span class="string">&quot;gorm:table_options&quot;</span>, <span class="string">&quot;charset=utf8mb4&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewDBClient</span><span class="params">(ctx context.Context)</span></span> *gorm.DB &#123;</span><br><span class="line">db := _db</span><br><span class="line"><span class="keyword">return</span> db.WithContext(ctx)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的增删改查</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ProductDao <span class="keyword">struct</span> &#123;</span><br><span class="line">*gorm.DB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProductDao</span><span class="params">(ctx context.Context)</span></span> *ProductDao &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ProductDao&#123;NewDBClient(ctx)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewProductDaoByDB</span><span class="params">(db *gorm.DB)</span></span> *ProductDao &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ProductDao&#123;db&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取商品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ProductDao)</span></span> GetProduct(id <span class="type">uint</span>) (product *model.Product, err <span class="type">error</span>) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CreateProduct 创建商品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ProductDao)</span></span> CreateProduct(product *model.Product) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DeleteProduct 删除商品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ProductDao)</span></span> DeleteProduct(id <span class="type">uint</span>) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UpdateProduct 更新商品</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dao *ProductDao)</span></span> UpdateProduct(id <span class="type">uint</span>, product *model.Product) <span class="type">error</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过product_test.go进行测试发现结果符合预期。接下来需要增加基本的缓存。</p><p>首先增加本地缓存</p><p><code>local_cache.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓存数据的结构</span></span><br><span class="line"><span class="keyword">type</span> Cache <span class="keyword">struct</span> &#123;</span><br><span class="line">mu      sync.RWMutex</span><br><span class="line">data    <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">expires <span class="keyword">map</span>[<span class="type">string</span>]time.Time</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个新的缓存</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCache</span><span class="params">()</span></span> *Cache &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cache&#123;</span><br><span class="line">data:    <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;),</span><br><span class="line">expires: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]time.Time),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向缓存中添加数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Set(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;, expiration time.Duration) &#123;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">c.data[key] = value</span><br><span class="line">c.expires[key] = time.Now().Add(expiration)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从缓存中获取数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cache)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">c.mu.RLock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.RUnlock()</span><br><span class="line">value, ok := c.data[key]</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">expiration, exists := c.expires[key]</span><br><span class="line"><span class="keyword">if</span> !exists || time.Now().Before(expiration) &#123;</span><br><span class="line"><span class="keyword">return</span> value, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 数据已过期，从缓存中删除</span></span><br><span class="line"><span class="built_in">delete</span>(c.data, key)</span><br><span class="line"><span class="built_in">delete</span>(c.expires, key)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>local_cache_test.go</code>中进行测试，可以看到cache缓存的执行时间远小于DB查询</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--------普通DB查询-------</span><br><span class="line">运行时长：547.3µs</span><br><span class="line">&amp;&#123;12 2 DB测试 123 33&#125;</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----有缓存DB第一查询-----</span><br><span class="line">运行时长：519.8µs</span><br><span class="line">&amp;&#123;6 1 缓存测试 123 33&#125;</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----有缓存缓存查询-----</span><br><span class="line">运行时长：0s</span><br><span class="line">&amp;&#123;6 1 缓存测试 123 33&#125;</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p>当然，验证完了查询问题，还需要设计缓存一致性</p><p>缓存一致性是业务层面的设计。所以在业务代码中进行书写。接下来加入<code>redis_cache</code></p><p><code>redis_cache.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RedisCache <span class="keyword">struct</span> &#123;</span><br><span class="line">client *redis.Client</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRedisCache 创建一个新的 Redis 缓存实例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRedisCache</span><span class="params">()</span></span> *RedisCache &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;RedisCache&#123;</span><br><span class="line">client: redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 如果有密码，设置密码</span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// 默认数据库</span></span><br><span class="line">PoolSize: <span class="number">1000</span>,</span><br><span class="line">&#125;),</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ping 用于测试 Redis 连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *RedisCache)</span></span> Ping() <span class="type">error</span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">pong, err := rc.client.Ping(ctx).Result()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;无法连接到 Redis: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;Redis 连接成功:&quot;</span>, pong)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 用于设置缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *RedisCache)</span></span> Set(key, value <span class="type">string</span>, expiration time.Duration) <span class="type">error</span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">err := rc.client.Set(ctx, key, value, expiration).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;设置缓存失败: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Get 用于获取缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *RedisCache)</span></span> Get(key <span class="type">string</span>) (<span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">cacheValue, err := rc.client.Get(ctx, key).Result()</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, err</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;&quot;</span>, fmt.Errorf(<span class="string">&quot;获取缓存失败: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cacheValue, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delete 用于删除缓存数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rc *RedisCache)</span></span> Delete(key <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">ctx := context.Background()</span><br><span class="line">err := rc.client.Del(ctx, key).Err()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;删除缓存失败: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用测试函数测试，发现结果符合预期</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">--------普通DB查询-------</span><br><span class="line">运行时长：642.4µs</span><br><span class="line">&amp;&#123;12 2 DB测试 123 33&#125;</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----有缓存DB第一查询-----</span><br><span class="line">运行时长：306.4407ms</span><br><span class="line">&amp;&#123;6 1 缓存测试 123 33&#125;</span><br><span class="line">-----------------------</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-----有缓存缓存查询-----</span><br><span class="line">运行时长：0s</span><br><span class="line">&amp;&#123;6 1 缓存测试 123 33&#125;</span><br><span class="line">-----------------------</span><br></pre></td></tr></table></figure><p>那么在业务中如何去写呢，简单的写一下<code>service</code>模块</p><p>首先实现一下GetData模块</p><p><code>service/product.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ProductSrvIns *ProductSrv</span><br><span class="line"><span class="keyword">var</span> ProductSrvOnce sync.Once</span><br><span class="line"><span class="keyword">var</span> key <span class="type">string</span> = <span class="string">&quot;product:&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ProductSrv <span class="keyword">struct</span> &#123;</span><br><span class="line">localCache *cache.Cache</span><br><span class="line">redisCache *cache.RedisCache</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetProductSrv</span><span class="params">()</span></span> *ProductSrv &#123;</span><br><span class="line">ProductSrvOnce.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">ProductSrvIns = &amp;ProductSrv&#123;</span><br><span class="line">localCache: cache.LocalCache,</span><br><span class="line">redisCache: cache.RDCache,</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> ProductSrvIns</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductSrv)</span></span> GetData(c *gin.Context, pId <span class="type">uint</span>) (product *model.Product, err <span class="type">error</span>) &#123;</span><br><span class="line">uniqueKey := key + fmt.Sprint(pId)</span><br><span class="line"><span class="comment">// 查本地缓存</span></span><br><span class="line"><span class="keyword">if</span> value, ok := ps.localCache.Get(uniqueKey); ok &#123;</span><br><span class="line"><span class="comment">// 一级缓存查询有值</span></span><br><span class="line">product = &amp;model.Product&#123;&#125;</span><br><span class="line">err = json.Unmarshal(value.([]<span class="type">byte</span>), product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;反序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则查二级缓存</span></span><br><span class="line">value, err := ps.redisCache.Get(uniqueKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询异常</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != redis.Nil &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询无果</span></span><br><span class="line"><span class="comment">// 查询数据库中的数据</span></span><br><span class="line">product, err = dao.NewProductDao(c).GetProduct(pId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line"><span class="comment">// 查询无果</span></span><br><span class="line"><span class="keyword">return</span> &amp;model.Product&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonData []<span class="type">byte</span></span><br><span class="line">jsonData, err = json.Marshal(*product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新缓存</span></span><br><span class="line">ps.redisCache.Set(uniqueKey, <span class="type">string</span>(jsonData), <span class="number">60</span>*time.Second)</span><br><span class="line">ps.localCache.Set(uniqueKey, <span class="type">string</span>(jsonData), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">product = &amp;model.Product&#123;&#125;</span><br><span class="line">jsonData := []<span class="type">byte</span>(value)</span><br><span class="line">err = json.Unmarshal(jsonData, product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;反序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时实现增删改三个部分</p><p>为了简单实现，把表单需要传输的数据通过随机数实现</p><p><code>service/product.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductSrv)</span></span> UpdateData(c *gin.Context, pId <span class="type">uint</span>, newPrice <span class="type">float64</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="comment">// 先操作数据库，在删除缓存是比较好的选择</span></span><br><span class="line"><span class="comment">// 后删除防止别的线程进入数据库查询</span></span><br><span class="line">uniqueKey := key + fmt.Sprint(pId)</span><br><span class="line"><span class="comment">// 更新数据库</span></span><br><span class="line"><span class="keyword">if</span> err = dao.NewProductDao(c).UpdateProduct(pId, &amp;model.Product&#123;Price: newPrice&#125;); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新缓存, 从下到上</span></span><br><span class="line">err = ps.redisCache.Delete(uniqueKey)</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ps.localCache.Delete(uniqueKey)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductSrv)</span></span> DeleteData(c *gin.Context, pId <span class="type">uint</span>) (err <span class="type">error</span>) &#123;</span><br><span class="line">uniqueKey := key + fmt.Sprint(pId)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err = dao.NewProductDao(c).DeleteProduct(pId); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新缓存, 从下到上</span></span><br><span class="line">err = ps.redisCache.Delete(uniqueKey)</span><br><span class="line"><span class="keyword">if</span> err == redis.Nil &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">ps.localCache.Delete(uniqueKey)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductSrv)</span></span> CreateData(c *gin.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">pid := rand.Intn(<span class="number">10000</span>)</span><br><span class="line">uniqueKey := key + fmt.Sprint(pid)</span><br><span class="line">newProduct := &amp;model.Product&#123;</span><br><span class="line">PID:  <span class="type">uint</span>(pid),</span><br><span class="line">Name: <span class="string">&quot;测试&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = dao.NewProductDao(c).CreateProduct(newProduct); err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">data, err := json.Marshal(newProduct)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = ps.redisCache.Set(uniqueKey, <span class="type">string</span>(data), <span class="number">60</span>*time.Second)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">ps.localCache.Set(uniqueKey, data, <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然，完成了基本业务实现，需要去考虑一些缓存会出现的问题，也就是业务难点</p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>因为大量的缓存数据在同一时间过期失效，或者redis宕机，导致大量的访问请求打到数据库层。使得数据库阻塞影响业务进度。</p><p>上面已经通过二级缓存缓解了这种情况，还可以使用过期时间随机化去解决。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，大量的请求访问会在瞬间给数据库带来巨大的冲击。</p><p>这里可以使用互斥锁和逻辑过期去实现</p><ul><li>互斥锁实现简单，但是高并发情况下会发生阻塞</li></ul><p><img src="https://s2.loli.net/2023/10/12/DbsjJFXN5nIYERk.png" alt="互斥锁实现"></p><ul><li>逻辑过期实现有点难度，且对redis有一定的内存占用。同时也容易发生脏读</li></ul><p><img src="https://s2.loli.net/2023/10/11/eTn7fdLN8iVYlBj.png" alt="逻辑过期"></p><p>使用逻辑过期的用户体验比较好一点，但是会对内存占用比较高，也会发生脏读的现象。</p><p>本次demo准备使用二级缓存，所以可以两个同时使用</p><p>对第一层使用逻辑过期，第二层使用互斥锁实现（目前仅实现互斥锁）</p><p>在service&#x2F;Product.go中增加互斥锁相关</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *ProductSrv)</span></span> GetData(c *gin.Context, pId <span class="type">uint</span>) (product *model.Product, err <span class="type">error</span>) &#123;</span><br><span class="line">uniqueKey := key + fmt.Sprint(pId)</span><br><span class="line"><span class="comment">// 模拟requestId</span></span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line">requestId := fmt.Sprint(rand.Intn(<span class="number">10000000</span>))</span><br><span class="line"><span class="comment">// 查本地缓存</span></span><br><span class="line"><span class="keyword">if</span> value, ok := ps.localCache.Get(uniqueKey); ok &#123;</span><br><span class="line"><span class="comment">// 一级缓存查询有值</span></span><br><span class="line">product = &amp;model.Product&#123;&#125;</span><br><span class="line">err = json.Unmarshal(value.([]<span class="type">byte</span>), product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;反序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则查二级缓存</span></span><br><span class="line">value, err := ps.redisCache.Get(uniqueKey)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询异常</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err != redis.Nil &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询无果</span></span><br><span class="line"><span class="comment">// 查询数据库中的数据</span></span><br><span class="line"><span class="comment">// redis 上锁</span></span><br><span class="line"><span class="keyword">var</span> locked <span class="type">bool</span></span><br><span class="line">locked, err = ps.redisCache.SetNx(c, lockKey, requestId)</span><br><span class="line"><span class="keyword">defer</span> ps.redisCache.Unlock(c, lockKey, requestId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> !locked &#123;</span><br><span class="line">time.Sleep(<span class="number">50</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">return</span> ps.GetData(c, pId)</span><br><span class="line">&#125;</span><br><span class="line">product, err = dao.NewProductDao(c).GetProduct(pId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line"><span class="comment">// 查询无果</span></span><br><span class="line"><span class="keyword">return</span> &amp;model.Product&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jsonData []<span class="type">byte</span></span><br><span class="line">jsonData, err = json.Marshal(*product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更新缓存</span></span><br><span class="line">ps.redisCache.Set(uniqueKey, <span class="type">string</span>(jsonData), <span class="number">60</span>*time.Second)</span><br><span class="line">ps.localCache.Set(uniqueKey, <span class="type">string</span>(jsonData), <span class="number">10</span>*time.Second)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">product = &amp;model.Product&#123;&#125;</span><br><span class="line">jsonData := []<span class="type">byte</span>(value)</span><br><span class="line">err = json.Unmarshal(jsonData, product)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;反序列化失败:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里setNx+EX实际还能增加一个守护进程来进行锁的续期，但是我没实现，有读者有能力可以尝试去实现一下。对于用redis实现互斥锁的相关问题，建议大家看一下这篇文章<a href="http://xiaoheinotes.com/2023/09/25/redis-distributed-locks/">Go实战：redis分布式锁开发问题</a></p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是整个查询流程都被使用，一般是被黑客攻击的常用手段。</p><p>常用的解决手段有</p><ul><li>缓存null值</li><li>布隆过滤</li><li>增强id的复杂度，避免被猜测id规律</li><li>做好数据的基础格式校验</li><li>加强用户权限校验</li><li>做好热点参数的限流</li></ul><p>对于上面两个，可以两个都用，缓存null值比较好实现，只需要在mysql查为空值的时候进行赋值即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">product, err = dao.NewProductDao(c).GetProduct(pId)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err == gorm.ErrRecordNotFound &#123;</span><br><span class="line">        <span class="comment">// 查询无果</span></span><br><span class="line">        <span class="comment">// 防止缓存穿透</span></span><br><span class="line">        ps.localCache.Set(uniqueKey, <span class="string">&quot;&quot;</span>, <span class="number">10</span>*time.Second)</span><br><span class="line">        ps.redisCache.Set(c, uniqueKey, <span class="string">&quot;&quot;</span>, <span class="number">60</span>*time.Second)</span><br><span class="line">        <span class="keyword">return</span> &amp;model.Product&#123;&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就相当于是一个null值设置</p><p>同时实现布隆过滤，减少缓存的压力</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">import</span> <span class="string">&quot;github.com/bits-and-blooms/bloom&quot;</span></span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">filter := bloom.NewWithEstimates(<span class="number">1000000</span>, <span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !filter.Test([]<span class="type">byte</span>(fmt.Sprint(pId))) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里加上了后其他增加的就要做适当的调整</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n1 := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line">binary.BigEndian.PutUint64(n1, <span class="type">uint64</span>(pid))</span><br><span class="line">ps.filter.Add(n1)</span><br></pre></td></tr></table></figure><h3 id="redis锁实现超卖避免"><a href="#redis锁实现超卖避免" class="headerlink" title="redis锁实现超卖避免"></a>redis锁实现超卖避免</h3><p>超卖的问题一种经典的并发问题，因为多个线程同时再判断库存足够的时候，扣除库存时的这段时间并不是瞬时完成的，而这个问题也导致了超卖的问题。</p><p><img src="https://s2.loli.net/2023/10/12/dIo2iNFw5LK81Xv.png" alt="超卖情况"></p><p>假设线程1过来查询库存，判断出来库存大于1，正准备去扣减库存，但是还没有来得及去扣减，此时线程2过来，线程2也去查询库存，发现这个数量一定也大于1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。</p><p>对于超卖的解决有很多方法，此前做过一些解决超卖的demo测试<a href="https://github.com/yxh175/shop_demo">超卖解决demo</a></p><ul><li>悲观锁</li></ul><p>悲观锁可以实现对于数据的串行化执行，比如通过信号量，和lock都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等</p><ul><li>乐观锁</li></ul><p>乐观锁会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas</p><p>乐观锁的典型代表：就是cas，利用cas进行无锁化机制加锁，var5 是操作前读取的内存值，while中的var1+var2 是预估值，如果预估值 &#x3D;&#x3D; 内存值，则代表中间没有被人修改过，此时就将新值去替换 内存值。</p><p>在上面demo中，通过在数据库中加入version自动，每次开启一个事务，当减完之后，验证版本是否符合预期，如果不符合就要进行事务的取消，执行创建订单失败</p><ul><li>lua + redis锁</li></ul><p>通过lua脚本在redis之中进行原子性的操作，并在redis中进行订单的逻辑判断，最后把订单通过stream进行消息队列的分发，实现数据库的持久化。</p><h4 id="lua脚本特性"><a href="#lua脚本特性" class="headerlink" title="lua脚本特性"></a>lua脚本特性</h4><p>原子性，这个是大家对lua脚本在redis中的第一印象，保证原子性的主要原因还是Redis采用了单线程执行模型。也就是说，当Redis执行Lua脚本时，Redis会把Lua脚本作为一个整体并把它当作一个任务加入到一个队列中，然后单线程按照队列的顺序依次执行这些任务，在执行过程中Lua脚本是不会被其他命令或请求打断，因此可以保证每个任务的执行都是原子性的。</p><h4 id="如何用go去加载lua脚本呢？"><a href="#如何用go去加载lua脚本呢？" class="headerlink" title="如何用go去加载lua脚本呢？"></a>如何用go去加载lua脚本呢？</h4><p>可以使用go-redis去执行<code>.lua</code>脚本</p><p>通过script.Load得到对应的lua脚本</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// createScript 通过加载[]byte&#123;&#125;加载lua脚本</span></span><br><span class="line">script := createScript()</span><br><span class="line">sha, err := script.Load(ctx, client).Result()</span><br></pre></td></tr></table></figure><h3 id="Zap及ELK日志分析实践"><a href="#Zap及ELK日志分析实践" class="headerlink" title="Zap及ELK日志分析实践"></a>Zap及ELK日志分析实践</h3><p>系统通过Zap生成日志，推送到<code>Message Queue</code>中，之后再配置<code>logstash</code>将其写入到<code>ES</code>中，最后在<code>Kibana</code>中展示流程图如下</p><p><img src="https://s2.loli.net/2023/10/14/baCn8HQ4o6ZEweu.png" alt="ELK流程图"></p><h4 id="定制化Zap实现"><a href="#定制化Zap实现" class="headerlink" title="定制化Zap实现"></a>定制化Zap实现</h4><p>首先创建 logger，其有一个输出到 <code>console</code> 的 <code>zapcore</code>。和一个添加同步日志到 <code>redis</code> 的 <code>zapcore</code>，通过 <code>zapcore.AddSync</code> 可以将一个实现 <code>io.Writer</code> 接口的对象转为 <code>zap</code> 需要的 <code>WriteSyncer</code>。</p><p><code>util/logger/logger.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> logger</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;gin-mall/elk_demo/util/rwriter&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;go.uber.org/zap&quot;</span></span><br><span class="line"><span class="string">&quot;go.uber.org/zap/zapcore&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLogger</span><span class="params">(rw *rwriter.RedisWriter)</span></span> *zap.Logger &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置日志级别</span></span><br><span class="line">lowPriority := zap.LevelEnablerFunc(<span class="function"><span class="keyword">func</span><span class="params">(l zapcore.Level)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> l &gt;= zapcore.DebugLevel</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用json格式日志</span></span><br><span class="line">jsonEnc := zapcore.NewJSONEncoder(zap.NewProductionEncoderConfig())</span><br><span class="line">stdCore := zapcore.NewCore(jsonEnc, zapcore.Lock(os.Stdout), lowPriority)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rw实现io.Writer的接口</span></span><br><span class="line">syncer := zapcore.AddSync(rw)</span><br><span class="line">redisCore := zapcore.NewCore(jsonEnc, syncer, lowPriority)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 集成多个内核</span></span><br><span class="line">core := zapcore.NewTee(stdCore, redisCore)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 输出console且标识调用代码行</span></span><br><span class="line"><span class="keyword">return</span> zap.New(core).WithOptions(zap.AddCaller())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及一个<code>redisWriter</code></p><p><code>rwriter/rediswriter.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> rwriter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/redis/go-redis/v9&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rWriter *RedisWriter</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RedisWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">cli     *redis.Client</span><br><span class="line">listKey <span class="type">string</span></span><br><span class="line">c       context.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *RedisWriter)</span></span> Write(p []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">n, err := w.cli.RPush(w.c, w.listKey, p).Result()</span><br><span class="line"><span class="keyword">return</span> <span class="type">int</span>(n), err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewRedisWriter</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewRedisWriter</span><span class="params">()</span></span> *RedisWriter &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">rWriter = &amp;RedisWriter&#123;</span><br><span class="line">cli: redis.NewClient(&amp;redis.Options&#123;</span><br><span class="line">Addr:     <span class="string">&quot;localhost:6379&quot;</span>, <span class="comment">// Redis 服务器地址</span></span><br><span class="line">Password: <span class="string">&quot;&quot;</span>,               <span class="comment">// 如果有密码，设置密码</span></span><br><span class="line">DB:       <span class="number">0</span>,                <span class="comment">// 默认数据库</span></span><br><span class="line">PoolSize: <span class="number">1000</span>,</span><br><span class="line">&#125;),</span><br><span class="line">listKey: <span class="string">&quot;log_queue&quot;</span>,</span><br><span class="line">c:       context.Background(),</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> rWriter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过运行Test函数，可以看一下Redis中是否更新</p><h4 id="搭建ELK环境"><a href="#搭建ELK环境" class="headerlink" title="搭建ELK环境"></a>搭建ELK环境</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;好久之前做的简单电子商城项目，进行一下回顾，并试着复述一下项目的难点与亮点&lt;/p&gt;
&lt;p&gt;这里有针对这些问题的demo，&lt;a href=&quot;https://github.com/yxh175/web-small-demo&quot;&gt;电子商城亮点demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="总结" scheme="http://xiaoheinotes.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
    <category term="电子商城" scheme="http://xiaoheinotes.com/tags/%E7%94%B5%E5%AD%90%E5%95%86%E5%9F%8E/"/>
    
  </entry>
  
  <entry>
    <title>笔试记录：集度</title>
    <link href="http://xiaoheinotes.com/2023/10/09/exam-jidu/"/>
    <id>http://xiaoheinotes.com/2023/10/09/exam-jidu/</id>
    <published>2023-10-09T13:03:15.000Z</published>
    <updated>2023-10-13T12:47:37.049Z</updated>
    
    <content type="html"><![CDATA[<p>集度笔试，编程题全考字符串了，难度不高</p><h2 id="存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组。"><a href="#存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组。" class="headerlink" title="存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组。"></a>存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组。</h2><p>有一些要求</p><ul><li>按子序列数组顺序返回</li><li>重复不返回</li></ul><p>只能过80%，代码如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bufio&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    input := bufio.NewScanner(os.Stdin)</span><br><span class="line">    input.Scan()</span><br><span class="line">    dataStr := strings.Split(input.Text(), <span class="string">&quot;,&quot;</span>)</span><br><span class="line">    input.Scan()</span><br><span class="line">    s := input.Text()</span><br><span class="line"></span><br><span class="line">    res := parseWord(s, dataStr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(res); i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span> &#123;</span><br><span class="line">            fmt.Print(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        fmt.Print(res[i])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parseWord</span><span class="params">(s <span class="type">string</span>, subsequence []<span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    result := []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    set := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">bool</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, sub := <span class="keyword">range</span> subsequence &#123;</span><br><span class="line">        <span class="keyword">if</span> !set[sub] &amp;&amp; isSub(s, sub) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, sub)</span><br><span class="line">            set[sub] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSub</span><span class="params">(s, sub <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(s) &amp;&amp; j &lt; <span class="built_in">len</span>(sub) &#123;</span><br><span class="line">        <span class="keyword">if</span> s[i] == sub[j] &#123;</span><br><span class="line">            j++</span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> j == <span class="built_in">len</span>(sub)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="重复的DNA序列"><a href="#重复的DNA序列" class="headerlink" title="重复的DNA序列"></a>重复的DNA序列</h2><p>leetcode原题：<a href="https://leetcode.cn/problems/repeated-dna-sequences/">重复的DNA序列</a></p><p>简单起见直接用hash表写了，核心代码模式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatedDnaSequences</span><span class="params">(s <span class="type">string</span>)</span></span> (ans []<span class="type">string</span>) &#123;</span><br><span class="line">    cnt := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s)<span class="number">-10</span>; i++ &#123;</span><br><span class="line">        sub := s[i : i+<span class="number">10</span>]</span><br><span class="line">        cnt[sub]++</span><br><span class="line">        <span class="keyword">if</span> cnt[sub] == <span class="number">2</span> &#123;</span><br><span class="line">            ans = <span class="built_in">append</span>(ans, sub)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;集度笔试，编程题全考字符串了，难度不高&lt;/p&gt;
&lt;h2 id=&quot;存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组。&quot;&gt;&lt;a href=&quot;#存在一个子序列数组和一个字符串，判断多个子序列是否存在于字符串中，是的话返回对应的子序列数组</summary>
      
    
    
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>笔试记录：奇安信</title>
    <link href="http://xiaoheinotes.com/2023/10/09/exam-qianxin/"/>
    <id>http://xiaoheinotes.com/2023/10/09/exam-qianxin/</id>
    <published>2023-10-09T07:53:38.000Z</published>
    <updated>2023-10-11T06:01:45.934Z</updated>
    
    <content type="html"><![CDATA[<p>2023年10月9日笔试，整体难度不高，40min结束战斗，不太记得清除题了，只知道是什么类型的，简单的描述一下</p><h2 id="芭莎慈善夜明星捐款"><a href="#芭莎慈善夜明星捐款" class="headerlink" title="芭莎慈善夜明星捐款"></a>芭莎慈善夜明星捐款</h2><p>核心代码模式<br>实际就是<a href="https://leetcode.cn/problems/house-robber-ii/">打家劫舍2</a>，明星围坐在一起进行捐款</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rob</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max(maxSteal(nums[<span class="number">1</span>:]), maxSteal(nums[:<span class="built_in">len</span>(nums)<span class="number">-1</span>]))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSteal</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a := nums[<span class="number">0</span>]</span><br><span class="line">    b := max(nums[<span class="number">0</span>], nums[<span class="number">1</span>])</span><br><span class="line">    c := b</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        c = max(a + nums[i], b)</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断资源使用是否异常"><a href="#判断资源使用是否异常" class="headerlink" title="判断资源使用是否异常"></a>判断资源使用是否异常</h2><p>题目巨长，没仔细看，总的来说就是给定一个数组, 然后1是获取资源，0是损失资源，最终满足两个要求</p><ul><li>资源在中间不会为负</li><li>资源最后为0</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 1 1 0 0 0</span><br><span class="line"></span><br><span class="line">true</span><br><span class="line"></span><br><span class="line">1 0 1 1 1 0 0 1</span><br><span class="line"></span><br><span class="line">false</span><br><span class="line"></span><br><span class="line">1 0 1 1 0 0 0 1</span><br><span class="line"></span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>本地没写直接线上写的, 思路比较简单一个cnt做记录</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isGood</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i ++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums(i) == <span class="number">1</span> &#123;</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt --</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> cnt &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt == <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就这么一小点，感觉应该是没HC了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;2023年10月9日笔试，整体难度不高，40min结束战斗，不太记得清除题了，只知道是什么类型的，简单的描述一下&lt;/p&gt;
&lt;h2 id=&quot;芭莎慈善夜明星捐款&quot;&gt;&lt;a href=&quot;#芭莎慈善夜明星捐款&quot; class=&quot;headerlink&quot; title=&quot;芭莎慈善夜明星捐款&quot;</summary>
      
    
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试总结：操作系统之网络系统</title>
    <link href="http://xiaoheinotes.com/2023/10/07/interview-os-networkSystem/"/>
    <id>http://xiaoheinotes.com/2023/10/07/interview-os-networkSystem/</id>
    <published>2023-10-07T13:41:10.000Z</published>
    <updated>2023-10-09T07:53:18.233Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要参考<a href="https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E6%9C%AF">小林coding</a>，来进行网络系统知识相关的回忆</p><p>网络在计算机网络中的地位很重要，同样的在操作系统中去实现网络的底层也很重要，接下来研究一下常见的面试问题</p><h2 id="什么是零拷贝？"><a href="#什么是零拷贝？" class="headerlink" title="什么是零拷贝？"></a>什么是零拷贝？</h2><p>这个是一个面试高频问题，答案也是见字知其意。</p><p>零拷贝是指计算机执行IO操作时，CPU不需要将数据从一个存储区域复制到另一个存储区域，从而可以减少上下文切换以及CPU的拷贝时间。它是一种I&#x2F;O操作优化技术。</p><p>它的优势在于：</p><ul><li>减少内存复制的操作</li><li>提高性能</li><li>减少CPU开销</li></ul><h3 id="DMA技术"><a href="#DMA技术" class="headerlink" title="DMA技术"></a>DMA技术</h3><p>DMA技术即(Direct Memory Access) 技术，就是一种直接访问内存的技术。在没有这个技术之前。<br>I&#x2F;O过程往往需要CPU不断的中断，来将磁盘的缓冲区的数据的写入到寄存器中。此期间是无法执行其他任务的。也就是说当传输大量数据文件，都使用CPU进行搬运，CPU的用户进程就会频繁的陷入<strong>阻塞等待</strong>的状态</p><p>因此科学家就提出了DMA技术，来直接进行内存访问。</p><p>简单理解DMA技术即：在进行I&#x2F;O设备和内存的数据传输的时候，数据搬运的工作全部交给了DMA控制器，而CPU不再参与数据搬运相关的事情，这样CPU就可以去处理别的事务。</p><p>也就是说DMA就是一个写入装置，对于简单的写入也不再需要劳烦CPU，只需要使用DMA控制器就行。随着设计的不断提升，每个I&#x2F;O设备都有了自己的DMA控制器</p><h4 id="是否有了DMA控制器，CPU就不参与写入了"><a href="#是否有了DMA控制器，CPU就不参与写入了" class="headerlink" title="是否有了DMA控制器，CPU就不参与写入了"></a>是否有了DMA控制器，CPU就不参与写入了</h4><p>并不能这么绝对的说，准确的来说是CPU不参与 将数据从磁盘控制器缓冲区搬运到内核空间 的简单工作。这部分由DMA完成，CPU还是会参与写入调度，这时CPU更像一个管理者，只负责调度</p><h3 id="传统的文件传输有多糟糕"><a href="#传统的文件传输有多糟糕" class="headerlink" title="传统的文件传输有多糟糕"></a>传统的文件传输有多糟糕</h3><p>如果服务端要提供文件传输的功能，直观的去想最简单的方式还是通过CPU去进行中断拷贝</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/%E4%BC%A0%E7%BB%9F%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93.png" alt="传统文件传输"></p><p>这期间会发生两次CPU拷贝和两次DMA，两次CPU拷贝也就是要进行四次CPU状态切换。</p><p>一份数据要拷贝四次，看起来有点繁琐与不划算。</p><p>所以要怎么解决呢？核心的问题是如何减少上下文切换次数和拷贝次数</p><h3 id="优化文件传输性能的方法"><a href="#优化文件传输性能的方法" class="headerlink" title="优化文件传输性能的方法"></a>优化文件传输性能的方法</h3><h4 id="减少用户态与内核态的上下文切换次数"><a href="#减少用户态与内核态的上下文切换次数" class="headerlink" title="减少用户态与内核态的上下文切换次数"></a>减少用户态与内核态的上下文切换次数</h4><p>读取磁盘数据的时候，之所以要发生上下文切换，这是因为用户空间没有权限操作磁盘或网卡，内核的权限最高，这些操作设备的过程都需要交由操作系统内核来完成，所以一般要通过内核去完成某些任务的时候，就需要使用操作系统提供的系统调用函数。</p><p>而一次系统调用必然会发生 2 次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。</p><p>所以，要想减少上下文切换到次数，就要减少系统调用的次数。</p><h4 id="减少数据拷贝次数"><a href="#减少数据拷贝次数" class="headerlink" title="减少数据拷贝次数"></a>减少数据拷贝次数</h4><p>可以看到流程图中CPU拷贝次数多的原因是因为要拷贝到用户缓冲区中，如果用户缓冲区不会对数据加工，可以不把数据搬到缓冲区中，直接进行发送</p><h3 id="如何实现零拷贝？"><a href="#如何实现零拷贝？" class="headerlink" title="如何实现零拷贝？"></a>如何实现零拷贝？</h3><p>实现零拷贝的方法通常有两种</p><ul><li>mmap + write</li><li>sendfile</li></ul><h4 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h4><p>这里的优化是替换了原本的read函数，换成mmap函数。这两个函数的区别是什么呢？</p><ul><li>read函数： 将内核态缓存区的内容拷贝到用户缓冲区</li><li>mmap函数： 将内核态缓存区共享给用户缓冲区</li></ul><p>所以就可以少一次拷贝，如下流程</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/mmap%20%2B%20write%20%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="mmap拷贝"></p><p>但是这时仍然需要调用两次函数，进行四次上下文切换</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p>senffile是一个专门发送文件的系统函数，相当于它可以一次替代read()和write()两个系统调用。减少一次系统调用，只需要两次上下文切换，三次数据拷贝，流程如下：</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-3%E6%AC%A1%E6%8B%B7%E8%B4%9D.png" alt="sendfile"></p><p>如果网卡支持SG-DMA(The Scatter-Gather Direct Memory Access)，可以大幅减少拷贝次数</p><p>SG-DMA技术即：</p><ul><li>通过DMA将磁盘数据拷贝到内核缓冲区中</li><li>缓冲区描述符和数据长度传到socket缓冲区，然后将实际数据传输到网卡中。就又可以减少一次拷贝</li></ul><p>使用SG-DMA的流程如下</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E9%9B%B6%E6%8B%B7%E8%B4%9D/senfile-%E9%9B%B6%E6%8B%B7%E8%B4%9D.png" alt="SG-DMA"></p><p>所谓的零拷贝（Zero-copy）技术，因为我们没有在内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><p>零拷贝技术的文件传输方式相比传统文件传输的方式，减少了 2 次上下文切换和数据拷贝次数，只需要 2 次上下文切换和数据拷贝次数，就可以完成文件的传输，而且 2 次的数据拷贝过程，都不需要通过 CPU，2 次都是由 DMA 来搬运。</p><p>所以，总体来看，零拷贝技术可以把文件传输的性能提高至少一倍以上</p><h4 id="哪些项目使用了零拷贝技术"><a href="#哪些项目使用了零拷贝技术" class="headerlink" title="哪些项目使用了零拷贝技术"></a>哪些项目使用了零拷贝技术</h4><p>Kafka、Nginx</p><h3 id="PageCache-有什么作用？"><a href="#PageCache-有什么作用？" class="headerlink" title="PageCache 有什么作用？"></a>PageCache 有什么作用？</h3><p>PageCache即磁盘高速缓存，也是内核缓冲区。</p><p>由于零拷贝使用PageCache，可以使得零拷贝进一步得到提升。</p><p>使用PageCache就相当于使用了一个缓存区。缓存一定数据所以它的主要优点有两个</p><ul><li>缓存最近被访问的数据</li><li>预读功能</li></ul><p>但是在传输大文件的时候，缓冲区的存在有时也会拖慢整个传输进度，白白浪费一次DMA拷贝。</p><p>因为传输大文件肯定是按照顺序依次传输，也就是说缓存击中的概率几乎为0。就导致了以下问题</p><ul><li>PageCache长时间被大文件覆盖，热点小文件无法使用pageCache</li><li>大文件无法享受PageCache的好处</li></ul><p>所以大文件的传输不应该使用PageCache进行传输，它最好使用什么呢？</p><h3 id="大文件传输用什么方式实现？"><a href="#大文件传输用什么方式实现？" class="headerlink" title="大文件传输用什么方式实现？"></a>大文件传输用什么方式实现？</h3><p>既然大文件使用PageCache进行传输有这么多负面的效果，那应该用什么实现呢？</p><p>通过用户态的异步I&#x2F;O和内核态的直接I&#x2F;O进行处理，减少进入PageCache的次数。从而减少拷贝次数</p><h2 id="I-O多路复用：-select-poll-epoll"><a href="#I-O多路复用：-select-poll-epoll" class="headerlink" title="I&#x2F;O多路复用： select&#x2F;poll&#x2F;epoll"></a>I&#x2F;O多路复用： select&#x2F;poll&#x2F;epoll</h2><p>I&#x2F;O多路复用，在后端邻域的面试是常考面试题。在Socket网络模型中，I&#x2F;O多路复用在优化过程也是必不可少的。</p><h3 id="最基本的Socket模型"><a href="#最基本的Socket模型" class="headerlink" title="最基本的Socket模型"></a>最基本的Socket模型</h3><p>基本的客户端和服务端通信，就必须依赖Socket编程，它是进程间通信里比较特别的方式，特别之处在于它是可以跨主机间通信的。</p><p>Socket即套接字模型。基于IP和端口进行的一个定位。一般来说，服务端首先调用socket()函数，创建网络协议为IPV4以及传输协议为TCP的Socket。接着调用bind()函数，给这个Socket绑定Ip和端口。绑定IP查找主机位置，绑定端口查找对应接收程序。</p><p>绑定完IP和端口后会调用listen()函数进入监听状态，通过调用accept()函数来从内核获取客户端的连接，如果没有客户端连接就会进入阻塞态</p><p>服务端准备就绪后，就需要客户端进行剩下的操作了</p><p>客户端在需要和服务端连接的时候会进行connect()函数连接服务端从而建立TCP连接。之后就可以正常的进行read和write的调用了</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/tcp_socket.png" alt="Socket模型"></p><h3 id="多进程模型"><a href="#多进程模型" class="headerlink" title="多进程模型"></a>多进程模型</h3><p>可以看到传统的阻塞网络I&#x2F;O模型，如果服务端要想支持多个客户端就必须开启多个进程去调用监听函数。这种很容易想到的方法就是多进程模型。</p><p>服务器的主进程负责监听客户的连接，一旦与客户端连接完成，accept() 函数就会返回一个「已连接 Socket」，这时就通过 fork() 函数创建一个子进程，实际上就把父进程所有相关的东西都复制一份，包括文件描述符、内存地址空间、程序计数器、执行的代码等。</p><p>子进程不需要关心监听，只需要进行连接，父进程掌握着监听，将连接交给子进程，父进程就像是一个经理，只需要安排好客户端让谁服务即可</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E5%A4%9A%E8%BF%9B%E7%A8%8B.png" alt="多进程模型"></p><p>但是这种fork子进程的缺点也显而易见，随着连接量的增大，系统的负担也逐渐增大。进程间上下文切换对CPU性能的损耗影响也很大。于是多线程模型也被提出</p><h3 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h3><p>为了解决进程切换损耗大的问题的，将这一系列操作降到轻量级的线程。</p><p>它的思路是通过一个全局加锁队列去让线程池并发获取socket连接。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png" alt="多线程模型"></p><p>但这样也存在一个问题，就是如果存在大量的用户去连接，会导致维护超多线程。对操作系统的要求非常大。所以需要一个更好的解决方案去完善它。于是I&#x2F;O多路复用技术被推上议程</p><h3 id="I-O多路复用"><a href="#I-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>前面提到的模型基本都是需要调度单位去为每个socket进行服务。现在我们从CPU的角度看一下，当CPU如何在一段时间内处理多个请求呢？没错，就是复用。</p><p>所以I&#x2F;O多路复用就被提出了，虽然一个进程任意时刻只能处理一个请求，但只要这请求处理的足够快，来回的上下文切换就会形成并发处理的过程。</p><p><img src="https://s2.loli.net/2023/10/09/w73g49KtAyvHCIQ.png" alt="进程复用"></p><p>基于这种思想多路复用也出现了多个复用算法。</p><ul><li>select</li><li>poll</li><li>epoll</li></ul><h4 id="select"><a href="#select" class="headerlink" title="select"></a>select</h4><p>select实现多路复用的方式比较粗暴，将已经连接的Socket都放在一个文件描述符集合中，调用select讲个文件描述符集合中的数据拷贝到内核中，让内核通过遍历文件描述符集合的方式检查是否有网络事件发生。<br>当检查到有事件发生时，就把这个事件进行标记可读或可写，再拷贝回用户态。用户态再通过遍历找到这个标记，就可以对其进行处理了。</p><p>可以看到select的思路有一点暴力，需要进行两次遍历、两次拷贝才能实现。而且select使用固定大小长度的BitsMap去进行标记，由于Linux系统限制，导致select一次只能处理0~1023的文件描述符</p><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll前面的思路和select的方法类似，不同的是对集合的表示，poll对集合使用的是动态数组进行的表示，对数量不在有限制。</p><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>一般面试最常问的问题就是epoll和select的区别。</p><p>区别主要是针对select的部分进行改进，select部分的问题有哪些？</p><ul><li>集合整体拷贝效率低</li><li>暴力轮询内核占用高</li></ul><p>针对上面这两个问题epoll很好的解决了。</p><p>对于集合拷贝问题：</p><p>epoll通过维护一个红黑树来跟踪进程所有待检测的文件描述字，把需要监控的socket通过<code>epoll_ctl()</code>函数加入内核中的红黑树中，也就是说epoll不用在每次操作时进行大量的拷贝，而是直接通过将socket加入到内核</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要参考&lt;a href=&quot;https://xiaolincoding.com/os/8_network_system/zero_copy.html#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89-dma-%E6%8A%80%E</summary>
      
    
    
    
    <category term="八股文" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="网络系统" scheme="http://xiaoheinotes.com/tags/%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>面试重点：docker常见面试题</title>
    <link href="http://xiaoheinotes.com/2023/10/07/interview-docker-key-point/"/>
    <id>http://xiaoheinotes.com/2023/10/07/interview-docker-key-point/</id>
    <published>2023-10-07T04:48:41.000Z</published>
    <updated>2023-10-07T08:18:46.702Z</updated>
    
    <content type="html"><![CDATA[<p>docker平时有用到一点，但并不是经常使用，只用过几个常用的命令，所以还是总结一下常见的docker面试题</p><h2 id="什么是docker"><a href="#什么是docker" class="headerlink" title="什么是docker"></a>什么是docker</h2><p>Go语言开发的一个容器虚拟化技术，使用C&#x2F;S架构，具有隔离、快速、轻便的特点</p><h2 id="Docker与虚拟机有什么不同？"><a href="#Docker与虚拟机有什么不同？" class="headerlink" title="Docker与虚拟机有什么不同？"></a>Docker与虚拟机有什么不同？</h2><p>虚拟机是模拟一个os系统去操作应用，这样的好处是简单。可以很容易的设置各种细节，并且用户也很容易理解多个系统之间的关系。docker不同，它取消了运行臃肿的客户机操作系统，取而代之的是守护进程。通过寄宿在主机中，可以直接与主系统进行通信，并为各个容器分配资源。一个容器就是一个隔绝的沙箱，其中包含着各个镜像。</p><h2 id="Docker镜像是什么？"><a href="#Docker镜像是什么？" class="headerlink" title="Docker镜像是什么？"></a>Docker镜像是什么？</h2><p>镜像可以理解为一个可以运行在docker容器中软件包，它包含了运行应用程序所需要的一切代码、运行时环境、系统工具、系统库以及预设的环境变量。镜像可以看作是容器的模板，容器是基于镜像创建的运行实例。</p><h2 id="Docker容器是什么？"><a href="#Docker容器是什么？" class="headerlink" title="Docker容器是什么？"></a>Docker容器是什么？</h2><p>Docker 容器是 Docker 平台上运行的独立的、可执行的应用程序单元。容器包含了应用程序及其所有依赖项，包括代码、运行时环境、系统工具、系统库以及预设的环境变量。容器是基于 Docker 镜像创建的实例，它们可以在任何支持 Docker 的环境中运行，而不受环境的影响。</p><h2 id="Docker容器有几种状态？"><a href="#Docker容器有几种状态？" class="headerlink" title="Docker容器有几种状态？"></a>Docker容器有几种状态？</h2><ul><li>运行</li><li>暂停</li><li>重启</li><li>退出</li></ul><h2 id="DockerFile常见指令"><a href="#DockerFile常见指令" class="headerlink" title="DockerFile常见指令"></a>DockerFile常见指令</h2><p>dockerFile常见命令如下</p><ol><li><p>FROM: 指定基础镜像，表示从哪里开始构建镜像。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">20.04</span></span><br></pre></td></tr></table></figure></li><li><p>MAINTAINER：指定镜像的作者信息。已经不推荐使用，一般可以用 LABEL 代替。</p></li><li><p>LABEL：为镜像添加元数据，通常用于提供关于镜像的信息，如版本、描述、维护者等。例如</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> version=<span class="string">&quot;1.0&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> description=<span class="string">&quot;My custom image&quot;</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"> maintainer=<span class="string">&quot;user@example.com&quot;</span></span></span><br></pre></td></tr></table></figure></li><li><p>RUN：在容器内执行命令，用于安装软件、配置环境等。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y package-name</span></span><br></pre></td></tr></table></figure></li><li><p>COPY 和 ADD：用于将文件从主机复制到容器内。COPY 用于复制文件和目录，而 ADD 可以用于复制文件、目录，并且支持解压缩。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COPY</span><span class="language-bash"> source_file /destination/</span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"> source_file.tar.gz /destination/</span></span><br></pre></td></tr></table></figure></li><li><p>WORKDIR：设置容器内的工作目录，后续的命令都将在这个目录下执行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br></pre></td></tr></table></figure></li><li><p>ENV：设置环境变量。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ENV</span> MY_VAR=value</span><br></pre></td></tr></table></figure></li><li><p>EXPOSE：声明容器在运行时监听的端口，但并不映射到宿主机上。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPOSE</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></li><li><p>CMD 和 ENTRYPOINT：用于设置容器启动时执行的命令。CMD 通常用于指定容器的默认命令，而 ENTRYPOINT 用于定义容器的入口点，可以与 CMD 结合使用。</p> <figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;app&quot;</span>, <span class="string">&quot;-d&quot;</span>]</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;my-entrypoint-script&quot;</span>]</span></span><br></pre></td></tr></table></figure></li><li><p>VOLUME：声明容器内的目录将被挂载为数据卷，用于持久化数据。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> /data</span></span><br></pre></td></tr></table></figure></li></ol><p>想要了解更多，这个网站有一些基础命令<a href="https://www.runoob.com/docker/docker-dockerfile.html">菜鸟docker教程</a></p><h2 id="DockerFile中命令COPY和ADD命令有什么区别？"><a href="#DockerFile中命令COPY和ADD命令有什么区别？" class="headerlink" title="DockerFile中命令COPY和ADD命令有什么区别？"></a>DockerFile中命令COPY和ADD命令有什么区别？</h2><p>两者都是可以将文件从主机复制到容器内。但是ADD额外增加解压的功能</p><h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p>常用的Docker命令主要分为五个部分：</p><ul><li>镜像相关</li><li>容器相关</li><li>容器和镜像管理</li><li>网络相关命令</li><li>Docker Compose</li></ul><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从Docker镜像仓库</span></span><br><span class="line">docker pull IMAGE_NAME:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本地已经下载的镜像</span></span><br><span class="line">docker images</span><br><span class="line">docker images ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除本地镜像 rmi</span></span><br><span class="line">docker rmi IMAGE_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">根据Dockerfile构建镜像</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-i: 交互式操作。</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-t: 终端。</span></span><br><span class="line">docker build -t IMAGE_NAME:TAG PATH_TO_DOCKERFILE</span><br></pre></td></tr></table></figure><h3 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建并运行容器。</span></span><br><span class="line">docker run -d IMAGE_NAME:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出正在运行的容器。</span></span><br><span class="line">docker ps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有容器，包括已停止的。</span></span><br><span class="line">docker ps -a</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已停止的容器。</span></span><br><span class="line">docker start CONTAINER_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止运行中的容器</span></span><br><span class="line">docker stop CONTAINER_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启容器。</span></span><br><span class="line">docker restart CONTAINER_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在容器内部执行交互式命令。</span></span><br><span class="line">docker exec -it CONTAINER_ID /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器的日志输出。</span></span><br><span class="line">docker logs CONTAINER_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除容器。</span></span><br><span class="line">docker rm CONTAINER_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清理所有停止的容器。</span></span><br><span class="line">docker container prune</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="容器和镜像管理"><a href="#容器和镜像管理" class="headerlink" title="容器和镜像管理"></a>容器和镜像管理</h3><p>感觉有点运维要用的，主要是对容器和镜像的管理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看容器或镜像的详细信息。</span></span><br><span class="line">docker inspect CONTAINER_OR_IMAGE_ID</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给镜像添加标签。</span></span><br><span class="line">docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">基于容器的当前状态创建新镜像。</span></span><br><span class="line">docker commit CONTAINER_ID NEW_IMAGE_NAME:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将镜像保存为 tar 文件</span></span><br><span class="line">docker save -o OUTPUT_FILE.tar IMAGE_NAME:TAG</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从 tar 文件加载镜像。</span></span><br><span class="line">docker load -i INPUT_FILE.tar</span><br></pre></td></tr></table></figure><h3 id="网络相关命令"><a href="#网络相关命令" class="headerlink" title="网络相关命令"></a>网络相关命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出所有 Docker 网络。</span></span><br><span class="line">docker network ls</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建一个自定义网络。</span></span><br><span class="line">docker network create NETWORK_NAME</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将容器连接到指定网络。</span></span><br><span class="line">docker network connect NETWORK_NAME CONTAINER_NAME</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从网络中断开容器。</span></span><br><span class="line">docker network disconnect NETWORK_NAME CONTAINER_NAME</span><br></pre></td></tr></table></figure><h3 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h3><p>Docker Compose 是一个用于定义和运行多容器 Docker 应用程序的工具，常用命令包括：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动应用程序。</span></span><br><span class="line">docker-compose up</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止并删除应用程序的容器和网络。</span></span><br><span class="line">docker-compose down</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建 Docker Compose 文件中定义的服务。</span></span><br><span class="line">docker-compose build</span><br></pre></td></tr></table></figure><p>当然这些是一些常用的命令，在工作中如果我们需要某些特殊的命令，可以尝试百度或者通过docker –help查找</p><h2 id="容器与主机之间的数据拷贝命令"><a href="#容器与主机之间的数据拷贝命令" class="headerlink" title="容器与主机之间的数据拷贝命令"></a>容器与主机之间的数据拷贝命令</h2><p>docker 主机和容器之间数据拷贝通常也是重要的，比如配置一个nginx时，通过数据拷贝命令，能更方便的把配置修改，而不需要每次启动都去进入容器去修改</p><h3 id="docker-cp-方式"><a href="#docker-cp-方式" class="headerlink" title="docker cp 方式"></a>docker cp 方式</h3><p>docker cp的方法就是直接复制文件到两者的两个方向</p><ul><li><p>从容器拷贝到主机</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp CONTAINER_ID:/path/to/container/file /path/on/host</span><br></pre></td></tr></table></figure></li><li><p>从主机拷贝到容器</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp CONTAINER_ID:/path/to/container/file /path/on/host</span><br></pre></td></tr></table></figure></li></ul><p>这样虽然不用打开容器，但每次修改完后都需要在执行一下复制命令，有没有什么比较好的方法去解决它呢？答案是有的，<strong>共享数据卷</strong>就是一个很好的解决方法</p><h3 id="共享数据卷"><a href="#共享数据卷" class="headerlink" title="共享数据卷"></a>共享数据卷</h3><p>Docker允许通过挂载数据卷的方式在容器和主机之间共享数据，将主机的目录挂载在容器内部，这样就能实现实时共享数据</p><ul><li><p>在容器启动时挂载主机目录到容器：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /path/on/host:/path/in/container IMAGE_NAME</span><br></pre></td></tr></table></figure></li><li><p>在容器内部创建数据卷并挂载到主机：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -v /path/in/container IMAGE_NAME</span><br><span class="line">docker cp CONTAINER_ID:/path/in/container /path/on/host</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用共享数据卷容器"><a href="#使用共享数据卷容器" class="headerlink" title="使用共享数据卷容器"></a>使用共享数据卷容器</h3><p>还有一种方法，通过创建一个容器作为数据管理中心。创建一个专门的数据卷容器，其他容器可以通过 <code>--volumes-from </code>参数来共享数据卷容器的数据卷。这种方式可以用于在多个容器之间共享数据。</p><ul><li><p>创建数据卷容器</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -v /data --name data-container IMAGE_NAME</span><br></pre></td></tr></table></figure></li><li><p>启动其他容器并共享数据卷</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --volumes-from data-container -it ubuntu</span><br></pre></td></tr></table></figure></li></ul><h2 id="docker-使用nginx的主要流程"><a href="#docker-使用nginx的主要流程" class="headerlink" title="docker 使用nginx的主要流程"></a>docker 使用nginx的主要流程</h2><ul><li>首先获取镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nginx:latest</span><br></pre></td></tr></table></figure><ul><li>查看本地镜像</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li>创建容器运行并挂载路径</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name nginx-test -p 8080:80 -d -v &lt;主机路径&gt; &lt;容器路径&gt; nginx  </span><br></pre></td></tr></table></figure><h2 id="什么是Docker-Swarm"><a href="#什么是Docker-Swarm" class="headerlink" title="什么是Docker Swarm"></a>什么是Docker Swarm</h2><p>Docker Swarm 是 Docker 的一个集群和编排工具，用于管理和编排多个 Docker 容器的部署。它允许将多个 Docker 主机组成一个集群，并将容器应用程序在这个集群中进行分布式部署和管理。</p><h2 id="如何批量清理临时镜像文件"><a href="#如何批量清理临时镜像文件" class="headerlink" title="如何批量清理临时镜像文件"></a>如何批量清理临时镜像文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -q)</span><br></pre></td></tr></table></figure><ul><li><code>-q</code> 选项表示只输出镜像的 <code>ID</code>，而不包括其他信息。</li><li><code>$(...)：</code>这是命令替换的语法，它会将 <code>docker images -q</code>的输出结果作为参数传递给下一个命令。</li><li><code>docker rmi -f</code>：这部分命令用于删除<code>Docker</code>镜像。<code>-f</code>选项表示强制删除，即使镜像正在被容器使用也会被删除。</li></ul><h2 id="如何查看镜像支持的环境变量？"><a href="#如何查看镜像支持的环境变量？" class="headerlink" title="如何查看镜像支持的环境变量？"></a>如何查看镜像支持的环境变量？</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在 Docker 容器中运行一个镜像，并显示容器中的环境变量。</span></span><br><span class="line">docker run &lt;镜像ID&gt; env</span><br></pre></td></tr></table></figure><ul><li><code>docker run</code>：这是 <code>Docker</code> 命令的一部分，用于启动一个新的容器。</li><li><code>&lt;镜像ID&gt;</code>：这是要运行的 <code>Docker</code> 镜像的 <code>ID</code>。</li><li><code>env</code>：这是在容器内部执行的命令。在这种情况下，它是一个简单的命令 <code>env</code>，用于显示容器的环境变量。</li></ul><h2 id="构建Docker镜像应该遵循哪些原则"><a href="#构建Docker镜像应该遵循哪些原则" class="headerlink" title="构建Docker镜像应该遵循哪些原则?"></a>构建Docker镜像应该遵循哪些原则?</h2><ol><li>尽量选取满足需求但较小的基础系统镜像</li><li>清理编译生成文件、安装包的缓存等临时文件</li><li>安装各个软件时候要指定准确的版本号，并避免引入不需要的依赖</li><li>从安全的角度考虑，应用尽量使用系统的库和依赖</li><li>使用Dockerfile创建镜像时候要添加.dockerignore文件或使用干净的工作目录</li></ol><h2 id="如何停止所有正在运行的容器"><a href="#如何停止所有正在运行的容器" class="headerlink" title="如何停止所有正在运行的容器?"></a>如何停止所有正在运行的容器?</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill $(docker ps -q)</span><br></pre></td></tr></table></figure><ul><li><code>docker ps -q</code>：这部分命令用于列出当前正在运行的 <code>Docker</code> 容器的 <code>ID</code>，其中 <code>-q</code> 选项表示只输出容器的 <code>ID</code>，而不包括其他信息。</li><li><code>$(...)</code>：这是命令替换的语法，它会将 <code>docker ps -q</code> 的输出结果（即正在运行的容器的 ID 列表）作为参数传递给下一个命令。</li><li><code>docker kill</code>：这部分命令用于停止 <code>Docker</code> 容器。当你执行 <code>docker kill CONTAINER_ID</code> 时，它会向指定的容器发送一个 SIGKILL 信号，强制停止容器的运行。</li></ul><p>整个命令的作用是将 <code>docker ps -q</code> 列出的所有正在运行的容器的 <code>ID</code> 传递给 <code>docker kill</code> 命令，从而停止所有运行中的 <code>Docker</code> 容器。</p><h2 id="如何清理批量后台停止的容器"><a href="#如何清理批量后台停止的容器" class="headerlink" title="如何清理批量后台停止的容器"></a>如何清理批量后台停止的容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Docker 将删除所有已停止的容器，释放它们占用的资源</span></span><br><span class="line">docker container prune</span><br></pre></td></tr></table></figure><h2 id="可以在一个容器中同时运行多个应用进程吗？"><a href="#可以在一个容器中同时运行多个应用进程吗？" class="headerlink" title="可以在一个容器中同时运行多个应用进程吗？"></a>可以在一个容器中同时运行多个应用进程吗？</h2><p>可以但不推荐</p><p>资源不好管理也容易出现冲突，监控也可能会出现冲突</p><h2 id="如何控制容器占用系统资源（CPU，内存）的份额？"><a href="#如何控制容器占用系统资源（CPU，内存）的份额？" class="headerlink" title="如何控制容器占用系统资源（CPU，内存）的份额？"></a>如何控制容器占用系统资源（CPU，内存）的份额？</h2><h3 id="CPU控制"><a href="#CPU控制" class="headerlink" title="CPU控制"></a>CPU控制</h3><ul><li><p><code>--cpus</code> 参数：使用 <code>--cpus</code> 参数可以限制容器使用的 <code>CPU</code> 核心数量。例如，以下命令限制容器只能使用 0.5 个 <code>CPU</code> 核心：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cpus=0.5 my_container</span><br></pre></td></tr></table></figure></li><li><p><code>--cpu-shares</code> 参数：使用 <code>--cpu-shares</code> 参数可以为容器分配 CPU 时间片的权重。较高的权重值表示容器将获得更多的 CPU 时间。例如，以下命令为容器分配了相对较高的 CPU 权重</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --cpu-shares=512 my_container</span><br></pre></td></tr></table></figure></li></ul><h3 id="内存控制"><a href="#内存控制" class="headerlink" title="内存控制"></a>内存控制</h3><ul><li><p><code>--memory</code> 参数：使用 <code>--memory</code> 参数可以限制容器使用的内存量。例如，以下命令限制容器最多使用 512MB 内存：</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --memory=512m my_container</span><br></pre></td></tr></table></figure></li><li><p><code>--memory-swap</code> 参数：使用 <code>--memory-swap</code> 参数可以限制容器的虚拟内存（包括物理内存和交换空间）使用。默认情况下，Docker 会将 <code>--memory-swap</code> 设置为无限制。例如，以下命令将容器的虚拟内存限制为 1GB（包括 512MB 物理内存和 512MB 交换空间）</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --memory=512m --memory-swap=1g my_container</span><br></pre></td></tr></table></figure></li></ul><h2 id="如何将一台宿主机的docker环境迁移到另外一台宿主机？"><a href="#如何将一台宿主机的docker环境迁移到另外一台宿主机？" class="headerlink" title="如何将一台宿主机的docker环境迁移到另外一台宿主机？"></a>如何将一台宿主机的docker环境迁移到另外一台宿主机？</h2><p>停止Docker服务，将整个docker存储文件复制到另外一台宿主机上，然后调整另外一台宿主机的配置即可</p><h2 id="什么是docker-compose"><a href="#什么是docker-compose" class="headerlink" title="什么是docker-compose"></a>什么是docker-compose</h2><p>使用 Docker Compose，你可以在本地开发和测试多容器应用程序，然后将相同的配置和定义部署到生产环境中，从而简化了容器化应用程序的开发、部署和管理过程。它是 Docker 生态系统中非常有用的工具之一。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;docker平时有用到一点，但并不是经常使用，只用过几个常用的命令，所以还是总结一下常见的docker面试题&lt;/p&gt;
&lt;h2 id=&quot;什么是docker&quot;&gt;&lt;a href=&quot;#什么是docker&quot; class=&quot;headerlink&quot; title=&quot;什么是docker&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="八股文" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="docker" scheme="http://xiaoheinotes.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>GO：反射实战编程</title>
    <link href="http://xiaoheinotes.com/2023/10/04/go-reflect-try/"/>
    <id>http://xiaoheinotes.com/2023/10/04/go-reflect-try/</id>
    <published>2023-10-04T01:34:45.000Z</published>
    <updated>2023-10-16T01:40:41.934Z</updated>
    
    <content type="html"><![CDATA[<p><code>reflect</code>包在<code>Golang</code>语言中有重要的作用。反射在计算机科学领域中，是指一个应用能够进行自描述、自控制。Golang中实现了反射，反射机制就是在运行时动态的调用对象的属性和方法。</p><p>reflect中有两个重要的函数和类型</p><p>两个函数</p><ul><li>reflect.TypeOf  获取类型信息</li><li>reflect.ValueOf  获取数据的运行时表示</li></ul><p>两个类型</p><ul><li>reflect.Type</li><li>reflect.Value</li></ul><p>reflect.Type是反射包定义的一个接口，其中定义了一些不错的方法。这里列举出来一些，如果感兴趣可以翻一下源码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Type <span class="keyword">interface</span> &#123;</span><br><span class="line">Align() <span class="type">int</span></span><br><span class="line">FieldAlign() <span class="type">int</span></span><br><span class="line">Method(<span class="type">int</span>) Method</span><br><span class="line">    <span class="comment">// 获取当前类型对应方法的引用</span></span><br><span class="line">MethodByName(<span class="type">string</span>) (Method, <span class="type">bool</span>)</span><br><span class="line">    <span class="comment">// 获取当前类型方法的数量</span></span><br><span class="line">NumMethod() <span class="type">int</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    <span class="comment">// 判断当前类型是否实现某个接口</span></span><br><span class="line">Implements(u Type) <span class="type">bool</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>reflect.Value</code>类型则不同，它是一个结构体。而且也只有三个字段。它以结构体的方法实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">typ *rtype</span><br><span class="line">ptr unsafe.Pointer</span><br><span class="line">flag</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="interface-与reflect"><a href="#interface-与reflect" class="headerlink" title="interface 与reflect"></a>interface 与reflect</h2><p>在了解reflect需要先知道interface的作用。可以把接口理解成电脑的一个接口。只要你符合接口方法的要求，你就能接入这个接口。在go1.18版本前，很多开发者利用interface的特性实现泛型的效果。这是因为interface作为一个边界类型，可以实现类型的接受。反射作为一个自描述、自控制的代码块。所以作为边界的interface{}是必不可少的。interface的灵活性是一把双刃剑，反射作为一种元编程方式，可以减少重复代码。但是过度的使用会导致程序逻辑不清晰，且会运行缓慢。</p><h2 id="GO-反射三大法则"><a href="#GO-反射三大法则" class="headerlink" title="GO 反射三大法则"></a>GO 反射三大法则</h2><ul><li>interface{} 变量可以转换成反射对象</li><li>从反射对象可以获取interface{}变量</li><li>要修改反射对象，其值必须可设置</li></ul><h3 id="第一法则"><a href="#第一法则" class="headerlink" title="第一法则"></a>第一法则</h3><p>反射是如何反射出对象的值并进行修改的。实际上，reflect过程中是发生了值传递，通过reflect.Value和reflect.Type进行接收</p><p>可以看以下ValueOf的源码, 我的go用的是1.20版本，这时使用的是any，如果你是1.18版本之前的话，这里就是interface{}。当然interface{}和any是相同的<code>type any = interface&#123;&#125;</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i any)</span></span> Value &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// <span class="doctag">TODO:</span> Maybe allow contents of a Value to live on the stack.</span></span><br><span class="line"><span class="comment">// For now we make the contents always escape to the heap. It</span></span><br><span class="line"><span class="comment">// makes life easier in a few places (see chanrecv/mapassign</span></span><br><span class="line"><span class="comment">// comment below).</span></span><br><span class="line">escapes(i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到这里进行了一个隐式的接口转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test := <span class="string">&quot;this is test&quot;</span></span><br><span class="line">x := reflect.ValueOf(test)</span><br><span class="line">fmt.Println(reflect.TypeOf(x))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img1.imgtp.com/2023/10/04/xTXtYXTB.png" alt="第一法则"></p><p>这个x实际就是一个新的<code>reflect.Value</code>对象。<code>reflect.TypeOf</code> 和 <code>reflect.ValueOf</code> 相当于是一个桥梁连接了interface{}和反射对象</p><h3 id="第二法则"><a href="#第二法则" class="headerlink" title="第二法则"></a>第二法则</h3><p>第二法则即：从反射对象获取interface{}变量</p><p>这个比较容易理解，通过Interface转换成interface</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">test := <span class="string">&quot;this is test&quot;</span></span><br><span class="line">x := reflect.ValueOf(test)</span><br><span class="line">newX := x.Interface().(<span class="type">string</span>)</span><br><span class="line">fmt.Println(newX)</span><br><span class="line">fmt.Println(reflect.TypeOf(newX))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this is test</span><br><span class="line">string</span><br></pre></td></tr></table></figure><p>这段代码的输出结果，符合预期，反射对象被成功转换成变量</p><p><img src="https://img1.imgtp.com/2023/10/04/VQDaMPcs.png" alt="第二法则"></p><p>通过这个方法就可以将反射转换成对象</p><h3 id="第三法则"><a href="#第三法则" class="headerlink" title="第三法则"></a>第三法则</h3><p>更新值的时候，要判断值是否可以更新</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(i)</span><br><span class="line">v.SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码初看貌似没有问题。但仔细看v时反射对象，对反射对象修改值，属于无效操作。程序为了防止错误就会崩溃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">panic: reflect: reflect.Value.SetInt using unaddressable value</span><br><span class="line"></span><br><span class="line">goroutine 1 [running]:</span><br><span class="line">reflect.flag.mustBeAssignableSlow(0x0?)</span><br><span class="line">C:/Program Files/Go/src/reflect/value.go:260 +0x85</span><br><span class="line">reflect.flag.mustBeAssignable(...)</span><br><span class="line">C:/Program Files/Go/src/reflect/value.go:247</span><br><span class="line">reflect.Value.SetInt(&#123;0xd966c0?, 0xe37968?, 0xd056a9?&#125;, 0xa)</span><br><span class="line">C:/Program Files/Go/src/reflect/value.go:2233 +0x48</span><br><span class="line">main.main()</span><br><span class="line">f:/goProject/go-learn/reflect/changeValueDemo/main.go:11 +0xb1</span><br><span class="line">exit status 2</span><br></pre></td></tr></table></figure><p>正确的修改原变量应该使用如下方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">1</span></span><br><span class="line">v := reflect.ValueOf(&amp;i)</span><br><span class="line">v.Elem().SetInt(<span class="number">10</span>)</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时就能正确输出结果，所以有个要点，反射要传指针，反射对象要指向指针的值才可以修改值</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;reflect&lt;/code&gt;包在&lt;code&gt;Golang&lt;/code&gt;语言中有重要的作用。反射在计算机科学领域中，是指一个应用能够进行自描述、自控制。Golang中实现了反射，反射机制就是在运行时动态的调用对象的属性和方法。&lt;/p&gt;
&lt;p&gt;reflect中有两个</summary>
      
    
    
    
    <category term="编程实战" scheme="http://xiaoheinotes.com/categories/%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/"/>
    
    
    <category term="reflect" scheme="http://xiaoheinotes.com/tags/reflect/"/>
    
  </entry>
  
  <entry>
    <title>面试重点：TCP如何保证可靠性</title>
    <link href="http://xiaoheinotes.com/2023/10/03/interview-tcp-reliability/"/>
    <id>http://xiaoheinotes.com/2023/10/03/interview-tcp-reliability/</id>
    <published>2023-10-03T09:32:21.000Z</published>
    <updated>2023-10-13T09:16:12.795Z</updated>
    
    <content type="html"><![CDATA[<p>文章内容主要参考：<a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0">小林coding</a></p><h2 id="TCP哪些机制保证了可靠性"><a href="#TCP哪些机制保证了可靠性" class="headerlink" title="TCP哪些机制保证了可靠性"></a>TCP哪些机制保证了可靠性</h2><ul><li>重传机制：通过对未送达信息的重新传输，最终保证每个数据都能抵达到对端</li><li>滑动窗口：通过窗口增加传输的效率，可以等待一个范围的包</li><li>流量控制：发送方会根据对方的滑动窗口来控制自己的发送速度</li><li>拥塞控制：网络传输过程丢包严重也会通过降低发送速度防止出现恶性循环</li></ul><h2 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h2><p>重传机制是为了保证，网络中报丢失后，能通过传输机制，最终保证报的正常传输</p><ul><li>超时重传</li><li>快速重传</li><li>SACK方法</li><li>D-SACK方法</li></ul><h3 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h3><p>超时重传的机制比较简单，只需要在每次发送时设置一个定时器，在定时器超时时没有收到ACK的话就会重发数据。这就是所谓的超时重传。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/5.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="超时重传"></p><h4 id="重传时间RTO（Retransmission-Timeout）设置多长合适"><a href="#重传时间RTO（Retransmission-Timeout）设置多长合适" class="headerlink" title="重传时间RTO（Retransmission Timeout）设置多长合适"></a>重传时间RTO（Retransmission Timeout）设置多长合适</h4><p>RTO较大会导致重发检测较慢，一次重发要好久，RTO较小会导致误判丢包次数过多，形成网络拥塞</p><p>最好设置刚好大于一个RTT往返时延</p><h3 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h3><p>所谓的快速重传，即是不依赖时间，而是根据丢包次数决定。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/10.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速重传"></p><p>快速重传中，当一个包被接受时，接受方就会返回ACK + 下一个需求的序列号。这样如果一个包丢失时，就会返回返回一个最左边未收到的序列号。这样多次后，发送方就会知道有一个包丢失了，就会快速的重传</p><p>快速重传解决了超时重传时间的问题，但是也衍生了另外一个问题。即重传最左边的一个，还是重传所有问题。为此工程师又设计了<code>SACK</code>重传机制</p><h3 id="SACK重传"><a href="#SACK重传" class="headerlink" title="SACK重传"></a>SACK重传</h3><p>SACK( Selective Acknowledgment) 即选择性确认<br>这种方式是在TCP头部中增加了一个SACK的参数。它将已收到的数据的信息发送给发送方。这样发送方就会知道哪些数据丢失了，哪些数据传输成功了。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/11.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="SACK重传"></p><p>SACK 会将最左侧的窗口保留，相当于告知发送方当前已经接受的数据。在ACK三次相同值触发快速重传时，传送方就能根据ACK的值和SACK的值推断出缺失的部分。</p><h3 id="D-SACK重传"><a href="#D-SACK重传" class="headerlink" title="D-SACK重传"></a>D-SACK重传</h3><p>SACK是为发送方丢包设计的保险协议。而丢包过程往往是双方的问题。当接受方的ACK包出现丢失或发送方出现延迟发送，就会出现重复数据的传输。为此TCP又提出了D-SACK重传模式。</p><p>小林coding中很好的用图总结了两个异常情况</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/12.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="ACK包丢失"></p><p>此时ACK多次丢失，导致发送方错误的任务自己的包没有发送成功，在RTO时间到的时候会触发超时重传。此时就会发送重复的数据。此时接受方回复了一个ACK大于SACK情况。这种情况就是D-SACK告知发送方数据重复了</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/13.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="ACK包延迟"></p><p>发送方延迟发送，导致发送方没有收到ACK的报文，所以它又重复了一次发送。这时候就出现了一次重复发送数据的情况。</p><p>这时也是一个D-SACK的情况，ACK的值大于SACK的范围。此时表示数据是重复的。此时发送方根据自己的发送记录，可以推测出，数据包在传输的时候出现了延迟。<br>D-SACK的好处有如下：</p><ul><li>可以让发送方知道，发出去的包是丢了，还是ACK丢了</li><li>可以知道发送的包是不是网络延迟了</li><li>可以知道网络中是不是把包复制了</li></ul><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a>什么是滑动窗口</h3><p>算法中滑动窗口的表现是一个一定大小的窗口，在整个数据的遍历过程像一个窗口滑动一样。TCP引入滑动窗口是为了实现多个包的传输，而不会因为一个一个的顺序接收而导致阻塞。如果是一个发送对应一个ACK，通信效率就会受到往返时延的瓶颈</p><p>有了窗口就可以无需等待确认应答，而可以继续发送大量的数据，即使有个ACK丢失了，也可以通过ACK的最大值表示确认应答位置。可以这么理解ACK的值就是告诉当前发送方我的最左窗口位置</p><h3 id="窗口大小由哪一方决定？"><a href="#窗口大小由哪一方决定？" class="headerlink" title="窗口大小由哪一方决定？"></a>窗口大小由哪一方决定？</h3><p>TCP中存在一个字段<code>Windows</code>，也就是窗口大小。<br>这个字段是接收方为了告诉发送端自己的缓冲区大小，发送端就可以根据这个Window的大小来控制自己发送的速度。而不会导致接收端处理不过来这些包</p><p>发送方的发送数据大小不能超过接受方的窗口大小，否则接收方就无法正常的接受数据</p><h3 id="发送方的滑动窗口"><a href="#发送方的滑动窗口" class="headerlink" title="发送方的滑动窗口"></a>发送方的滑动窗口</h3><p>发送方的滑动窗口由四个部分组成</p><ul><li>确认收到的部分</li><li>已发送但未收到的部分</li><li>未发送但在接收范围的部分</li><li>未发生且超过接收方范围的部分</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/19.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="发送方滑动窗口"></p><p>这四个部分通过推理可以得知接收方的接收情况</p><p>这个四部分的分割需要三条边界进行分割，分别是：</p><ul><li><code>SND.UNA</code> 绝对指针：接收方最后一个ACK的位置</li><li><code>SND.NXT</code> 绝对指针：发送方当前发送的位置</li><li><code>SND.UNA + SND.WND</code> 相对指针，通过接受方发送窗口大小的偏移量计算</li></ul><p>还可以发送数据的窗口大小 &#x3D; <code>SND.WND - (SND.NXT - SND.UNA)</code></p><h3 id="接收方的滑动窗口"><a href="#接收方的滑动窗口" class="headerlink" title="接收方的滑动窗口"></a>接收方的滑动窗口</h3><p>接收方的滑动窗口分为三个部分</p><ul><li>成功接收并确认的数据</li><li>未收到数据但可以接收的数据</li><li>未收到的数据并不可以接收的数据</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/20.jpg" alt="小林coding"></p><p>通过两个指针去控制</p><ul><li>RCV.WND 相对指针表示接收窗口大小</li><li>RCV.NXT 是一个绝对指针，它指向发送方发送来的下一个数据字节的序列号</li></ul><h3 id="接收窗口和发送窗口的大小是相等的吗？"><a href="#接收窗口和发送窗口的大小是相等的吗？" class="headerlink" title="接收窗口和发送窗口的大小是相等的吗？"></a>接收窗口和发送窗口的大小是相等的吗？</h3><p>并不完全相等，但是是约等于的。为什么不能保证完全相等是因为TCP连接中两端存在时延</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力<br>如果无脑的发送数据给对方，但对方处理不过来，就会导致重发机制的触发，对网络资源进行不必要的浪费</p><p>为此TCP提供了<strong>流量控制</strong>来保证发送方能根据接收方的实际接收能力控制发送的数据量。</p><p>通过控制窗口大小，来判断当前要发送多少数据</p><h3 id="操作系统缓冲区与滑动窗口的关系"><a href="#操作系统缓冲区与滑动窗口的关系" class="headerlink" title="操作系统缓冲区与滑动窗口的关系"></a>操作系统缓冲区与滑动窗口的关系</h3><p>一般来说发送窗口和接收窗口所存放的字节数，都是放在操作系统内存缓冲区中，操作系统的内存缓冲区的大小会被操作系统调整，当进程没办法及时读取缓冲区的内容时，也会对缓冲区造成影响</p><h4 id="操作系统缓冲区如何影响窗口？"><a href="#操作系统缓冲区如何影响窗口？" class="headerlink" title="操作系统缓冲区如何影响窗口？"></a>操作系统缓冲区如何影响窗口？</h4><p>可以有两个例子来举。可以通过图解很清楚的看到这个过程，图解来自小林coding讲的很清楚</p><p>考虑以下场景：</p><ul><li>客户端发送，服务端接收，初始窗口都是360</li><li>服务端繁忙。收到数据后应用层不能及时读取数据</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/22.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="缓冲阻塞1"></p><ol><li>客户端发送140字节的数据，可用变成220</li><li>服务端收到140字节数据，但是进程只读取40字节，还有100占用缓冲区，此时要让窗口收缩至260，发送确认信息，并告知当前窗口大小</li><li>客户端收到新的窗口大小后，就更新自己的窗口大小</li><li>客户端发送180字节的数据</li><li>服务端收到180字节的数据，因为进程阻塞就一点也没有读，此时窗口缩减至80，发送确认信息，并告知当前窗口大小</li><li>客户端收到新的窗口大小，更新自己的窗口大小</li><li>客户端发送80字节</li><li>服务端收到80字节后依旧是没有进行读取，此时窗口缩减为0，发送确认信息，并告知当前窗口大小</li><li>客户端接收到新的窗口，此时窗口为0，不进行发送</li></ol><p>还有一种情况是因为操作系统资源不足导致数据丢包。</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/23.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="数据丢包"></p><p>因为内存不足，会到导致，客户端误认为自己的包发送成功，将自己的窗口更新到一个诡异的负数</p><h3 id="窗口关闭"><a href="#窗口关闭" class="headerlink" title="窗口关闭"></a>窗口关闭</h3><p>在流量控制中，接收方通过对发送方窗口大小的约束实现流量控制，当窗口大小为0时，会阻止发送方给接收方传递数据，直到窗口变为非0，这个就是窗口关闭</p><h4 id="窗口关闭的潜在风险"><a href="#窗口关闭的潜在风险" class="headerlink" title="窗口关闭的潜在风险"></a>窗口关闭的潜在风险</h4><p>可以看到窗口关闭的原因一般是接收方无法处理发送方发送的数据，而进行的流量控制。假设接收在一定时间后有了足够的窗口去接收数据后，会发送一个窗口大小，来通知发送方更新窗口。以此来发送数据。<br>假如这个数据因为某些原因导致发送失败。可能会导致两者进入死锁</p><h4 id="TCP如何解决窗口关闭时，潜在的死锁现象？"><a href="#TCP如何解决窗口关闭时，潜在的死锁现象？" class="headerlink" title="TCP如何解决窗口关闭时，潜在的死锁现象？"></a>TCP如何解决窗口关闭时，潜在的死锁现象？</h4><p>其实思路也很简单，通过定时器来实现，发送增加一个探测定时器，每一段时间都会询问对方窗口是否增大</p><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>所谓糊涂窗口综合症是每次发送的数据都很少，对TCP每次运输的开销比较大。一般发送在流量控制导致的窗口变小后，因为应用层读取数据不连续，每次只能清理几个字节的小窗口让发送方发送。</p><p>所以糊涂窗口综合症可能发生的情况是</p><ul><li>接收方可以通告一个小的窗口</li><li>而发送可以发送小数据</li></ul><p>既然如此那么糊涂窗口综合症的解决思路也是从这两点下手：</p><ul><li>接收方不通告小窗口</li><li>发送发不发送小数据</li></ul><h4 id="怎么让接收方不通告小窗口？"><a href="#怎么让接收方不通告小窗口？" class="headerlink" title="怎么让接收方不通告小窗口？"></a>怎么让接收方不通告小窗口？</h4><p>接收方调整为窗口大小小于（MSS）缓存空间的1&#x2F;2时，就发送0</p><h4 id="怎么让发送方避免小数据呢？"><a href="#怎么让发送方避免小数据呢？" class="headerlink" title="怎么让发送方避免小数据呢？"></a>怎么让发送方避免小数据呢？</h4><p>延时处理</p><ul><li>要等窗口大小 &gt;&#x3D; MSS 且 数据大小 &gt;&#x3D; MSS</li><li>收到之前发送数据的ack回包</li></ul><p>满足以上两个条件才能进行发送</p><h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="为什么有了流量控制之后还要拥塞控制？"><a href="#为什么有了流量控制之后还要拥塞控制？" class="headerlink" title="为什么有了流量控制之后还要拥塞控制？"></a>为什么有了流量控制之后还要拥塞控制？</h3><p>这个在面试中经常问到，也是在刚学习时容易搞混的一个问题。其实也很好理解，所谓流量是指两个端口的表现，拥塞是之间传递的问题。所以流量控制解决两端流量大小问题，拥塞控制解决网络传输途中的拥塞问题</p><p>如果网络出现拥堵，不减少发送速率而继续进行大量的数据发送，会导致整个网络中的阻塞更加严重，形成恶性的循环，其实这个在计算机网络中的网络模块有类似的场景。<br>因此TCP提出了拥塞窗口的概念，来进行拥塞控制</p><h3 id="什么是拥塞窗口？和发送窗口的关系？"><a href="#什么是拥塞窗口？和发送窗口的关系？" class="headerlink" title="什么是拥塞窗口？和发送窗口的关系？"></a>什么是拥塞窗口？和发送窗口的关系？</h3><p>拥塞窗口cwnd是发送方维护的一个状态变量，它会根据网络的拥塞程度动态的变化。</p><p>在有拥塞窗口的情况下swnd &#x3D; min(cwnd, rwnd)</p><p>拥塞窗口cwnd的变化规则</p><ul><li>网络没有拥塞，cwnd会逐渐增大</li><li>网络出现拥塞，cwnd就会减少</li></ul><h3 id="如何直到当前网络是否拥塞呢？"><a href="#如何直到当前网络是否拥塞呢？" class="headerlink" title="如何直到当前网络是否拥塞呢？"></a>如何直到当前网络是否拥塞呢？</h3><p>一般来说没有按照期望时间内收到ACK应答报文，即发送超时重传就认为网络出现拥塞</p><h3 id="拥塞控制的一些算法"><a href="#拥塞控制的一些算法" class="headerlink" title="拥塞控制的一些算法"></a>拥塞控制的一些算法</h3><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发送</li><li>快速恢复</li></ul><h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>慢启动是在TCP连接刚建立完成时要执行的一个算法，它的核心作用是防止新建立的连接需要合适的初始化值去启动。否则容易出现网络阻塞。</p><p>慢启动的规则很简单：当发送方每收到一个ACK，拥塞窗口cwnd就会+1，表现情况会看到cwnd每一轮会乘指数增加</p><p>一个慢启动的过程举例如下：</p><ul><li>初始值 cwnd &#x3D; 1</li><li>发送一个数据，收到一个ack, cwnd +&#x3D; 1,此时cwnd &#x3D; 2</li><li>此时可以发送两个数据，收到两个ack，cwnd +&#x3D; 2 此时cwnd &#x3D; 4</li><li>以此类推可以看到cwnd每一轮会层指数性的增长</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/27.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="慢启动"></p><h4 id="什么时候慢启动停止"><a href="#什么时候慢启动停止" class="headerlink" title="什么时候慢启动停止"></a>什么时候慢启动停止</h4><p><code>ssthresh</code> （slow start threshold）状态变量，</p><ul><li>当cwnd &lt; ssthresh 时使用慢启动</li><li>当cwnd &gt;&#x3D; ssthresh 时使用拥塞避免</li></ul><h3 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h3><p>当拥塞窗口cwnd超过阈值就会进入拥塞避免。什么是拥塞避免呢？顾名思义，拥塞避免就是为了防止慢启动增长过大导致网络最终承受不了，所以要使用拥塞避免算法</p><p>拥塞避免算法的规则是：没收到一个ACK，cwnd会增加1&#x2F;cwnd 也就是说表现形式是线性增长</p><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/28.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="拥塞避免"></p><h3 id="拥塞发生"><a href="#拥塞发生" class="headerlink" title="拥塞发生"></a>拥塞发生</h3><p>我们可以看到上面两个现象都没有对增长进行限制，总体还会继续增长，这就难免会出现拥塞。当出现拥塞时，就会出现数据包重传。前面我们提到数据包重传有两种机制</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种重传机制的拥塞发生算法也不同</p><h4 id="超时重传下"><a href="#超时重传下" class="headerlink" title="超时重传下"></a>超时重传下</h4><p>这时ssthresh和cwnd都会变小</p><ul><li>ssthresh设为cwnd&#x2F;2</li><li>cwnd 设置为初始值</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost2/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/TCP-%E5%8F%AF%E9%9D%A0%E7%89%B9%E6%80%A7/29.jpg?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="超时重传的拥塞发生"></p><p>这种算法会导致网络传输的急刹车。反应过于强烈</p><h4 id="快速重传下"><a href="#快速重传下" class="headerlink" title="快速重传下"></a>快速重传下</h4><p>快速重传将这种网络包丢失严重性没有看的很重，但也会对cwnd和ssthresh两个值进行修改，同时会调用快速恢复算法</p><ul><li>cwnd &#x3D; cwnd &#x2F;2</li><li>ssthresh &#x3D; cwnd</li><li>快速恢复</li></ul><h3 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h3><p>快速重传使用快速恢复算法是因为快速恢复算法认为，你还能收到3个重复的ACK，说明网络不是态糟糕</p><p>快速恢复算法如下：</p><ul><li>拥塞窗口 cwnd &#x3D; ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p><img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png?image_process=watermark,text_5YWs5LyX5Y-377ya5bCP5p6XY29kaW5n,type_ZnpsdHpoaw,x_10,y_10,g_se,size_20,color_0000CD,t_70,fill_0" alt="快速恢复"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;文章内容主要参考：&lt;a href=&quot;https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0&quot;&gt;小林coding&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=</summary>
      
    
    
    
    <category term="八股" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="TCP" scheme="http://xiaoheinotes.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>面试重点：序列化</title>
    <link href="http://xiaoheinotes.com/2023/09/30/interview-serialization/"/>
    <id>http://xiaoheinotes.com/2023/09/30/interview-serialization/</id>
    <published>2023-09-30T11:52:47.000Z</published>
    <updated>2023-10-04T12:18:16.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是序列化和反序列化？"><a href="#什么是序列化和反序列化？" class="headerlink" title="什么是序列化和反序列化？"></a>什么是序列化和反序列化？</h2><ul><li>序列化： 将数据结构或对象或结构体转换成二进制字节的过程</li><li>反序列化：将序列化后的二进制字节流反序列化成数据结构或者对象</li></ul><h3 id="什么时候比较常用？"><a href="#什么时候比较常用？" class="headerlink" title="什么时候比较常用？"></a>什么时候比较常用？</h3><ul><li>RPC 网络传输</li><li>文件存储</li><li>存储到Redis缓存</li><li>存储到内存</li></ul><h3 id="序列化属于TCP-IP四层协议的哪一层，七层呢？"><a href="#序列化属于TCP-IP四层协议的哪一层，七层呢？" class="headerlink" title="序列化属于TCP&#x2F;IP四层协议的哪一层，七层呢？"></a>序列化属于TCP&#x2F;IP四层协议的哪一层，七层呢？</h3><p>四层协议</p><ul><li>应用层</li><li>传输层</li><li>网络层</li><li>网络接口层</li></ul><p>序列化属于程序中用于转换的操作，所以应该是最顶层于用户层的。所以是应用层的一部分。</p><h2 id="常见的序列化"><a href="#常见的序列化" class="headerlink" title="常见的序列化"></a>常见的序列化</h2><h3 id="java常见序列化"><a href="#java常见序列化" class="headerlink" title="java常见序列化"></a>java常见序列化</h3><ul><li>jdk序列：不推荐</li><li>Kryo序列化：由于其变长存储特性并使用了字节码生成机制，拥有较高的运行速度和较小的字节码体积。</li><li>Protobuf序列化：需要自己定义 IDL 文件和生成对应的序列化代码。</li><li>ProtoStuff序列化：基于Protobuf提供了更多的功能和更简易的用法</li><li>Hessian序列化：自定义描述的二进制 RPC 协议。</li></ul><h3 id="go常见序列化"><a href="#go常见序列化" class="headerlink" title="go常见序列化"></a>go常见序列化</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是序列化和反序列化？&quot;&gt;&lt;a href=&quot;#什么是序列化和反序列化？&quot; class=&quot;headerlink&quot; title=&quot;什么是序列化和反序列化？&quot;&gt;&lt;/a&gt;什么是序列化和反序列化？&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;序列化： 将数据结构或对象或结构体转换成二进制字</summary>
      
    
    
    
    <category term="八股文" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="序列化" scheme="http://xiaoheinotes.com/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Go实战：redis分布式锁开发问题</title>
    <link href="http://xiaoheinotes.com/2023/09/25/redis-distributed-locks/"/>
    <id>http://xiaoheinotes.com/2023/09/25/redis-distributed-locks/</id>
    <published>2023-09-25T09:30:28.000Z</published>
    <updated>2023-10-16T01:40:41.952Z</updated>
    
    <content type="html"><![CDATA[<p>之前金山面试被问到了怎么实现Redis分布式锁，但是答了个大概，但是再往深的问，就有些不会了。因此查了查相关博客，大概了解了整个过程。试着用一个redis + gin的小demo实战一下各种情况</p><h2 id="SetNX-和-EX-分开配置"><a href="#SetNX-和-EX-分开配置" class="headerlink" title="SetNX 和 EX 分开配置"></a>SetNX 和 EX 分开配置</h2><p>一般来说我们上来就会说，Set的时候设置一个<code>NX</code>参数。保证只能创建一个锁。 这个时候如果接下来的线程阻塞了就会导致整个系统都阻塞，这是在业务面上比较危险的事情。非原子情况下使用<code>EX|PX</code>来保证redis锁到期后，会自动删除。</p><p>一般来说go-redis很少出现这种情况。go-redis 使用了SetNx会自动配置一个时间，如果不想设置时间就设置成-1，也就是说，写一个分两步的操作某种程度上也挺难的</p><h2 id="因为某个业务异常，无法释放锁"><a href="#因为某个业务异常，无法释放锁" class="headerlink" title="因为某个业务异常，无法释放锁"></a>因为某个业务异常，无法释放锁</h2><p>释放锁失败，导致所有线程都无法拿到这个锁。好在可以用EX实现，这个就是一个很好的方法</p><h2 id="释放别人的锁"><a href="#释放别人的锁" class="headerlink" title="释放别人的锁"></a>释放别人的锁</h2><p>我第一次看到这个问题，我就很疑惑，这怎么可能会释放别人的锁呢？之后大概想了想。这种情况确实有可能发生。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;之前金山面试被问到了怎么实现Redis分布式锁，但是答了个大概，但是再往深的问，就有些不会了。因此查了查相关博客，大概了解了整个过程。试着用一个redis + gin的小demo实战一下各种情况&lt;/p&gt;
&lt;h2 id=&quot;SetNX-和-EX-分开配置&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="八股文" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
    
    <category term="redis" scheme="http://xiaoheinotes.com/tags/redis/"/>
    
    <category term="分布式锁" scheme="http://xiaoheinotes.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Go 实战：设计模式的实现</title>
    <link href="http://xiaoheinotes.com/2023/09/24/keypoint-design-patterns-todo/"/>
    <id>http://xiaoheinotes.com/2023/09/24/keypoint-design-patterns-todo/</id>
    <published>2023-09-24T13:13:07.000Z</published>
    <updated>2023-09-25T02:14:44.183Z</updated>
    
    <content type="html"><![CDATA[<p>最近做了很多笔试题，都提到了设计模式。非科班出身的鼠鼠之前了解过这些八股，但是都是浅尝而止。这次试着深入了解一下。用<code>go</code>实现相关思路</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式是最常用的一种设计模式，它的设计模式也是很好理解，就是保证返回相同内存的位置的同一实例。创建了就可以反复使用。在这基础上也出现了两种设计理念：</p><ul><li>饿汉式： 程序启动时就<code>init()</code>中创建好实例，不用考虑多线程下并发调用的问题</li><li>懒汉式： 等需要调用时，在创建实例，需要<strong>考虑多线程的会创建多个实例的异常情况</strong></li></ul><p>所以不难看出难点在于懒汉式的实现。在go中有很优雅的实现方法<code>sync.Once</code> 实现单例模式</p><p>创建文件 <code>instance.go</code> </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pattern_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Instance <span class="keyword">struct</span> &#123;</span><br><span class="line">Core <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance *Instance</span><br><span class="line"><span class="keyword">var</span> once sync.Once</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Instance &#123;</span><br><span class="line">once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">instance = &amp;Instance&#123;</span><br><span class="line">Core: <span class="string">&quot;first heart&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>sync.Once</code> 保证可以保证全局中只使用一次</p><p>创建文件 <code>instance_test.go</code> 用来测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pattern_test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestInstance</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">instance := GetInstance()</span><br><span class="line"></span><br><span class="line">fmt.Println(instance.Core)</span><br><span class="line">instance.Core = <span class="string">&quot;second heart&quot;</span></span><br><span class="line"></span><br><span class="line">instance = GetInstance()</span><br><span class="line">fmt.Println(instance.Core)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行测试符合预期</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestInstance</span><br><span class="line">first heart</span><br><span class="line">second heart</span><br><span class="line">--- PASS: TestInstance (0.00s)</span><br><span class="line">PASS</span><br><span class="line">ok      go_study/pattern_test   0.248s</span><br></pre></td></tr></table></figure><p>所以<code>go</code>实现懒汉模式还是很方便的</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式及，提供一个构造函数，通过传入不同的内容返回不同的类型的实例</p><p>下面是一个简单的工厂模式的样例</p><p>创建<code>factory.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigParser <span class="keyword">interface</span> &#123;</span><br><span class="line">Parse(data []<span class="type">byte</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> jsonConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> yamlConfigParser <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(jcp jsonConfigParser)</span></span> Parse(data []<span class="type">byte</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;jsonConfigParser model&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ycp yamlConfigParser)</span></span> Parse(data []<span class="type">byte</span>) &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;yamlConfigParser model&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewConfigParser</span><span class="params">(data <span class="type">string</span>)</span></span> ConfigParser &#123;</span><br><span class="line"><span class="keyword">switch</span> data &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;json&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> jsonConfigParser&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;yaml&quot;</span>:</span><br><span class="line"><span class="keyword">return</span> yamlConfigParser&#123;&#125;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">&quot;未知配置&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>创建 <code>factory_test.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> factory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;testing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNewConfigParser</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">parser1 := NewConfigParser(<span class="string">&quot;json&quot;</span>)</span><br><span class="line"></span><br><span class="line">parser2 := NewConfigParser(<span class="string">&quot;yaml&quot;</span>)</span><br><span class="line">parser1.Parse([]<span class="type">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">parser2.Parse([]<span class="type">byte</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过字段可以实现两种解释对象。通过接口让多个结构体实现这个结构。通过<code>New</code>进行分配</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">=== RUN   TestNewConfigParser</span><br><span class="line">jsonConfigParser model</span><br><span class="line">yamlConfigParser model</span><br><span class="line">--- PASS: TestNewConfigParser (0.00s)</span><br><span class="line">PASS</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近做了很多笔试题，都提到了设计模式。非科班出身的鼠鼠之前了解过这些八股，但是都是浅尝而止。这次试着深入了解一下。用&lt;code&gt;go&lt;/code&gt;实现相关思路&lt;/p&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="八股" scheme="http://xiaoheinotes.com/categories/%E5%85%AB%E8%82%A1/"/>
    
    
    <category term="golang" scheme="http://xiaoheinotes.com/tags/golang/"/>
    
    <category term="设计模式" scheme="http://xiaoheinotes.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>笔试回顾：美团9-23</title>
    <link href="http://xiaoheinotes.com/2023/09/23/exam-meituan/"/>
    <id>http://xiaoheinotes.com/2023/09/23/exam-meituan/</id>
    <published>2023-09-23T05:30:50.000Z</published>
    <updated>2023-09-23T07:12:20.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h2><p>总共五道编程题</p><h3 id="对于一个连串分数数组，计算小于前面最小成绩或者大于前面最大成绩的总数"><a href="#对于一个连串分数数组，计算小于前面最小成绩或者大于前面最大成绩的总数" class="headerlink" title="对于一个连串分数数组，计算小于前面最小成绩或者大于前面最大成绩的总数"></a>对于一个连串分数数组，计算小于前面最小成绩或者大于前面最大成绩的总数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    fmt.Scanln(&amp;n)</span><br><span class="line">    scores := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Scan(&amp;scores[i])</span><br><span class="line">    &#125;</span><br><span class="line">    cnt := countExameScores(scores)</span><br><span class="line">    fmt.Println(cnt)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countExameScores</span><span class="params">(scores []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(scores)</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    minScore := scores[<span class="number">0</span>]</span><br><span class="line">    maxScore := scores[<span class="number">0</span>]</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> scores[i] &lt; minScore || scores[i] &gt; maxScore &#123;</span><br><span class="line">            count++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> scores[i] &lt; minScore &#123;</span><br><span class="line">            minScore = scores[i]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> scores[i] &gt; maxScore &#123;</span><br><span class="line">            maxScore = scores[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路比较简单A了</p><h3 id="2-给一个24小时制时间的字符串经过多次对分钟的增加和减少，返回最后的时间"><a href="#2-给一个24小时制时间的字符串经过多次对分钟的增加和减少，返回最后的时间" class="headerlink" title="2. 给一个24小时制时间的字符串经过多次对分钟的增加和减少，返回最后的时间"></a>2. 给一个24小时制时间的字符串经过多次对分钟的增加和减少，返回最后的时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strconv&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> initTime <span class="type">string</span></span><br><span class="line">    fmt.Scanln(&amp;initTime)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    fmt.Scanln(&amp;n)</span><br><span class="line">    adjustments := <span class="built_in">make</span>([]<span class="type">string</span>, n)</span><br><span class="line">    adjustNums := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="comment">// input := bufio.NewScanner(os.Stdin)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Scanln(&amp;adjustments[i], &amp;adjustNums[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(adjustTime(initTime, adjustments, adjustNums))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adjustTime</span><span class="params">(initTime <span class="type">string</span>, adjustments []<span class="type">string</span>, adjustNums []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    timeNum := timeToInt(initTime)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(adjustNums); i++ &#123;</span><br><span class="line">        <span class="comment">// 减操作</span></span><br><span class="line">        <span class="keyword">if</span> adjustments[i] == <span class="string">&quot;-&quot;</span> &#123;</span><br><span class="line">            timeNum = (timeNum - adjustNums[i]%<span class="number">1440</span> + <span class="number">1440</span>) % <span class="number">1440</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> adjustments[i] == <span class="string">&quot;+&quot;</span> &#123;</span><br><span class="line">            timeNum = (timeNum + adjustNums[i]) % <span class="number">1440</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intTotime(timeNum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timeToInt</span><span class="params">(timeStr <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    parts := strings.Split(timeStr, <span class="string">&quot;:&quot;</span>)</span><br><span class="line">    hour, _ := strconv.Atoi(parts[<span class="number">0</span>])</span><br><span class="line">    minute, _ := strconv.Atoi(parts[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> hour*<span class="number">60</span> + minute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">intTotime</span><span class="params">(minutes <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    hour := minutes / <span class="number">60</span></span><br><span class="line">    minute := minutes % <span class="number">60</span></span><br><span class="line">    <span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%02d:%02d&quot;</span>, hour, minute)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只过了47%，因为没考虑减时间超过1440的情况</p><h3 id="3-有一个1-2-1-3-2-1-…-规律的数组，就是每k进行一次从前到后-1的操作，每一轮k-1，返回前n个序列的和"><a href="#3-有一个1-2-1-3-2-1-…-规律的数组，就是每k进行一次从前到后-1的操作，每一轮k-1，返回前n个序列的和" class="headerlink" title="3. 有一个1 2 1 3 2 1 … 规律的数组，就是每k进行一次从前到后-1的操作，每一轮k + 1，返回前n个序列的和"></a>3. 有一个1 2 1 3 2 1 … 规律的数组，就是每k进行一次从前到后-1的操作，每一轮k + 1，返回前n个序列的和</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> n <span class="type">int</span></span><br><span class="line">    fmt.Scan(&amp;n)</span><br><span class="line">    sqrtN := <span class="type">int</span>(math.Sqrt(<span class="type">float64</span>(<span class="number">2</span>*n))) + <span class="number">1</span></span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, sqrtN)</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; sqrtN; i++ &#123;</span><br><span class="line">        dp[i] = dp[i<span class="number">-1</span>] + i + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n-i &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        n -= i</span><br><span class="line">        sum += dp[i<span class="number">-1</span>]</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后处理</span></span><br><span class="line">    <span class="keyword">if</span> n != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            sum += i - j</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(sum)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>暴力会超时，需要去找规律</p><h3 id="4-好序列，-bi-bi-2-给定一个数组，找到最长子序列使其满足好序列"><a href="#4-好序列，-bi-bi-2-给定一个数组，找到最长子序列使其满足好序列" class="headerlink" title="4. 好序列， bi &#x3D; bi-2 给定一个数组，找到最长子序列使其满足好序列"></a>4. 好序列， bi &#x3D; bi-2 给定一个数组，找到最长子序列使其满足好序列</h3><p>没写出来</p><h3 id="5-给一个数组，-连续给q个-l，r，x-的三元组。如果x与从左到右的某个元素的乘积不是完全平方数就返回这个值，否则就返回-1"><a href="#5-给一个数组，-连续给q个-l，r，x-的三元组。如果x与从左到右的某个元素的乘积不是完全平方数就返回这个值，否则就返回-1" class="headerlink" title="5. 给一个数组， 连续给q个 l，r，x 的三元组。如果x与从左到右的某个元素的乘积不是完全平方数就返回这个值，否则就返回-1"></a>5. 给一个数组， 连续给q个 l，r，x 的三元组。如果x与从左到右的某个元素的乘积不是完全平方数就返回这个值，否则就返回-1</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    n, q := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    fmt.Scanln(&amp;n, &amp;q)</span><br><span class="line">    nums := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        fmt.Scan(&amp;nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 去除完全平方因子</span></span><br><span class="line">    newNums := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        newNums[i] = removeSquareFactors(nums[i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// fmt.Println(newNums)</span></span><br><span class="line">    fmt.Scanln()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; q; i++ &#123;</span><br><span class="line">        l, r, x := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">        fmt.Scanln(&amp;l, &amp;r, &amp;x)</span><br><span class="line">        res := findLeft(nums, newNums, l, r, x)</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findLeft</span><span class="params">(nums []<span class="type">int</span>, newNums []<span class="type">int</span>, l, r, x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    flag := isPerfectSquare(x)</span><br><span class="line">    <span class="keyword">for</span> i := l - <span class="number">1</span>; i &lt; r; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> newNums[i] == x || (flag &amp;&amp; newNums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isPerfectSquare</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sqrt := math.Sqrt(<span class="type">float64</span>(num))</span><br><span class="line">    <span class="keyword">return</span> sqrt == <span class="type">float64</span>(<span class="type">int</span>(sqrt))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeSquareFactors</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := n</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">2</span>; i*i &lt;= n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> n%(i*i) == <span class="number">0</span> &amp;&amp; isPerfectSquare(i*i) &#123;</span><br><span class="line">            res /= i * i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这题暴力会超时，没优化前过27%，优化后过0%。考虑可能是<code>removeSquareFactors</code>方法写的有问题，需要去修改，应该倒着去除完全平方因子</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;编程题&quot;&gt;&lt;a href=&quot;#编程题&quot; class=&quot;headerlink&quot; title=&quot;编程题&quot;&gt;&lt;/a&gt;编程题&lt;/h2&gt;&lt;p&gt;总共五道编程题&lt;/p&gt;
&lt;h3 id=&quot;对于一个连串分数数组，计算小于前面最小成绩或者大于前面最大成绩的总数&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/categories/%E7%AC%94%E8%AF%95/"/>
    
    
    <category term="笔试" scheme="http://xiaoheinotes.com/tags/%E7%AC%94%E8%AF%95/"/>
    
    <category term="美团" scheme="http://xiaoheinotes.com/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>面经：金山办公服务端开发</title>
    <link href="http://xiaoheinotes.com/2023/09/22/Interview-experience-KingSoft-WPS/"/>
    <id>http://xiaoheinotes.com/2023/09/22/Interview-experience-KingSoft-WPS/</id>
    <published>2023-09-22T04:56:12.000Z</published>
    <updated>2023-09-22T10:59:53.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h2><p>总共分为三个环节</p><ul><li>自我介绍</li><li>简历提问</li><li>算法考查</li></ul><h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>首先自我介绍了一下</p><h3 id="提问环节"><a href="#提问环节" class="headerlink" title="提问环节"></a>提问环节</h3><p>先是问一下比较基础的八股，然后逐渐变难的</p><h4 id="IP层有哪些协议？"><a href="#IP层有哪些协议？" class="headerlink" title="IP层有哪些协议？"></a>IP层有哪些协议？</h4><ul><li>DNS 用来根据域名进行网络查询</li><li>ARP 根据IP查询点之间的mac地址</li><li>DHCP 自动分配IP地址</li><li>NAT 私有地址转换为外网地址</li><li>ICMP 确认IP包是否成功送达到目标地址</li><li>IGMP</li></ul><h4 id="讲一下TCP的三次握手"><a href="#讲一下TCP的三次握手" class="headerlink" title="讲一下TCP的三次握手"></a>讲一下TCP的三次握手</h4><p>TCP三次握手即客户端和服务端连接时，两个者进行三次沟通的过程</p><ul><li>客户端发送SYNC + 随机seq序列号X</li><li>服务端监听到后回复ACK+SYNC ACK num&#x3D; X+1 SeqNum &#x3D; Y </li><li>客户端收到后， 回复ACK Ack num &#x3D; Y+1</li></ul><h4 id="为什么TCP连接要有seq序列号？"><a href="#为什么TCP连接要有seq序列号？" class="headerlink" title="为什么TCP连接要有seq序列号？"></a>为什么TCP连接要有seq序列号？</h4><ul><li>在TCP三次握手中保证了三次握手检查，不会有历史连接干扰</li><li>在传输时能进行报文的控制，方便进行拥塞控制、丢失重传、流量控制</li></ul><h4 id="讲一下四次挥手"><a href="#讲一下四次挥手" class="headerlink" title="讲一下四次挥手"></a>讲一下四次挥手</h4><p>TCP 四次挥手是客户端和服务端断开，进行的一个操作，保证TCP连接的正常断开</p><p>假设客户端主动关闭的时候</p><ul><li>客户端发送FIN请求 seq &#x3D; x、ack &#x3D; y</li><li>服务端收到FIN请求，回复ACK seq &#x3D; y 、ack &#x3D; x+1，进入Close_Wait并结束进程，进行最后的资源释放</li><li>等资源处理完毕后，发送FIN seq &#x3D; y、ack &#x3D; x + 1</li><li>此时客户端会进入Time_Wait状态发送ACK  seq &#x3D; x + 1， ack &#x3D; y + 1</li></ul><p>发送成功后，两者就进行了正常关闭</p><h4 id="为什么要有Time-Wait状态？"><a href="#为什么要有Time-Wait状态？" class="headerlink" title="为什么要有Time_Wait状态？"></a>为什么要有Time_Wait状态？</h4><ul><li>防止历史连接的数据影响新的连接，要让本次报文中的数据尽可能的在网络中消失掉。</li><li>保证被关闭的一方能够正确的关闭，多次监听服务端的消息，如果服务端再次发送关闭请求到客户端，说明自己的发送失败了。需要确保对方成功关闭</li></ul><h4 id="HTTP协议中一般有哪些状态码"><a href="#HTTP协议中一般有哪些状态码" class="headerlink" title="HTTP协议中一般有哪些状态码"></a>HTTP协议中一般有哪些状态码</h4><ul><li>1XX 属于提示信息，协议处理的中间态，一般用到的比较少</li><li>2XX 表示成功处理客户端的请求，是我们最想看到的如：200、204</li><li>3XX 表示资源发生了变动，如：301、302、304</li><li>4XX 表示客户端发送的报文有误如 404 资源不存在</li><li>5XX 表示服务端内部异常 如 500、501、502、503</li></ul><h4 id="499-状态码是做什么的有了解吗？"><a href="#499-状态码是做什么的有了解吗？" class="headerlink" title="499 状态码是做什么的有了解吗？"></a>499 状态码是做什么的有了解吗？</h4><p>这个没答上来。回答了说平时只了解过40x左右的。开发的时候没怎么见过</p><p>随后搜索：<br>499， Client Closed Request<br>这个表示客户端主动断开连接<br>是指一次http请求在客户端指定的时间内没有返回响应，此时客户端会主动断开连接，此时表象为客户端无响应返回，而nginx的日志会status code 499</p><h4 id="讲一下HTTPS的协议？"><a href="#讲一下HTTPS的协议？" class="headerlink" title="讲一下HTTPS的协议？"></a>讲一下HTTPS的协议？</h4><p>HTTPS 是基于HTTP的明文传输与不安全。所以在TCP三次握手后增加了TSL层作数据安全性的保证，通过TSL四次握手进行对称密钥的生成，实现对话过程中的加密。HTTPS可以保证主要用来保证信息的机密性、摘要算法的方式实现完整性、数字证书解决被冒充的方法</p><h4 id="HTTPS-能被抓包吗？"><a href="#HTTPS-能被抓包吗？" class="headerlink" title="HTTPS 能被抓包吗？"></a>HTTPS 能被抓包吗？</h4><p>我理解错了他的意思，以为问的是HTTPS能被窃听吗，所以回答成了：在保证对话密钥不被窃取，证书没有伪造的情况下。是不会被抓包的</p><p>理论答案：<br>可以通过抓包调试，通过抓包工具，并在手机中放好证书。保证系统能使用这个证书的情况下，就可以抓取到Https的内容</p><h4 id="有没有用过HTTPS抓包？"><a href="#有没有用过HTTPS抓包？" class="headerlink" title="有没有用过HTTPS抓包？"></a>有没有用过HTTPS抓包？</h4><p>当时脑子抽抽了，以为把抓包的意思理解错了，说没有T-T 实际上还是有的</p><p>正确回答：<br>通过抓包工具，把证书下载好，设置拦截端口号并拦截所发送的请求。即可得到解密后的包</p><h4 id="Golang-的GMP调度模式？"><a href="#Golang-的GMP调度模式？" class="headerlink" title="Golang 的GMP调度模式？"></a>Golang 的GMP调度模式？</h4><p>可以参考这篇文档<a href="https://juejin.cn/post/7044741465930465311">Go GMP</a>的图解，讲的非常清楚。为了方便，我就直接用他的图了</p><p>golang 的GMP调度老生常谈了</p><ul><li>G goroutine 代表程序中的协程</li><li>M machine 代表内核线程</li><li>P process 代表处理器</li></ul><p>P 会有一些本地队列，根据MAXPROCES 确定P的数量，P本地有个本地队列，用来存放协程。通过调用M来使用协程能够在M上运行。这样能保证M的线程能够多次复用，而且更加轻量。<br>为了保证协程资源分配的均匀提出了两个机制</p><ul><li>hand off 机制当本地线程M1因为G进行的系统调用阻塞时，线程释放绑定的P， 把P转移给其他空闲的M0执行</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df5d4f14311450dada8f4d6da82b896~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="hand off 机制"></p><ul><li>work stealing 机制</li></ul><p>当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b7c21037ed401292ec01aadfd906ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp" alt="work stealing 机制"></p><h4 id="怎么保证一个协程能一直占用一个CPU？"><a href="#怎么保证一个协程能一直占用一个CPU？" class="headerlink" title="怎么保证一个协程能一直占用一个CPU？"></a>怎么保证一个协程能一直占用一个CPU？</h4><p>加自旋锁让协程一直占用CPU。</p><h4 id="golang-怎么保证多个协程对int64进行增加不异常？"><a href="#golang-怎么保证多个协程对int64进行增加不异常？" class="headerlink" title="golang 怎么保证多个协程对int64进行增加不异常？"></a>golang 怎么保证多个协程对int64进行增加不异常？</h4><ul><li>sync.Mutex 互斥锁</li><li>sync.RWMutex 读写锁</li><li>Atomic.AddInt64() CAS锁</li></ul><h4 id="看你写了JAVA，-问你一点JAVA？"><a href="#看你写了JAVA，-问你一点JAVA？" class="headerlink" title="看你写了JAVA， 问你一点JAVA？"></a>看你写了JAVA， 问你一点JAVA？</h4><p>直接说不会T-T，学的皮毛，遂跳过</p><h4 id="Mysql-索引结构是什么样的？"><a href="#Mysql-索引结构是什么样的？" class="headerlink" title="Mysql 索引结构是什么样的？"></a>Mysql 索引结构是什么样的？</h4><p>B+树，是一种m度的树。它的特点就是在非叶子节点不会存放值。并且所有的值都会存放在叶子节点上，并用双向链表进行连接</p><h4 id="为什么要用B-树做索引"><a href="#为什么要用B-树做索引" class="headerlink" title="为什么要用B+树做索引"></a>为什么要用B+树做索引</h4><ul><li>插入和删除效率</li><li>范围查询更加方便</li></ul><h4 id="怎么用redis实现一个分布式锁？"><a href="#怎么用redis实现一个分布式锁？" class="headerlink" title="怎么用redis实现一个分布式锁？"></a>怎么用redis实现一个分布式锁？</h4><p>通过Set NX PX&#x2F;EX 两个字段保证分布式锁只有一个能加和超时自动清楚</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_key unique_value NX PX 10000 </span><br></pre></td></tr></table></figure><h4 id="怎么删除这个分布式锁？"><a href="#怎么删除这个分布式锁？" class="headerlink" title="怎么删除这个分布式锁？"></a>怎么删除这个分布式锁？</h4><p>通过判断lock_key value 是否是一个客户端。要保证执行操作的客户端就是加锁的客户端，所以解锁的时候要先判断 unique_value是否是当前客户端，是的话就删除锁</p><h4 id="怎么保证原子性？"><a href="#怎么保证原子性？" class="headerlink" title="怎么保证原子性？"></a>怎么保证原子性？</h4><p>通过Lua脚本实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 释放锁时，先比较 unique_value 是否相等，避免锁的误释放</span><br><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h4 id="Redis-有Stop-The-World的发生吗？"><a href="#Redis-有Stop-The-World的发生吗？" class="headerlink" title="Redis 有Stop The World的发生吗？"></a>Redis 有Stop The World的发生吗？</h4><p>刚开始听说STW以为是听错了。我说Redis没有STW的发生。他问一下我确定吗，Redis毕竟是一个单线程的。我一听就问他说的是不是主线程阻塞的问题。他说是就开始回答正常八股了</p><p>Redis 主线程会被大Key：Value阻塞主线程。因为在写日志的时候，大Key 导致的刷盘时间长，从而阻塞了主进程。这里<a href="https://xiaolincoding.com/redis/storage/bigkey_aof_rdb.html#%E5%A4%A7-key-%E5%AF%B9-aof-%E9%87%8D%E5%86%99%E5%92%8C-rdb-%E7%9A%84%E5%BD%B1%E5%93%8D">小林coding</a>讲的很详细</p><hr><p>这里八股就问差不多了，然后就问一些简单的算法题，只需要说思路就行</p><h4 id="100-个-10万数据的顺序表，怎么合并成一个新的顺序表？"><a href="#100-个-10万数据的顺序表，怎么合并成一个新的顺序表？" class="headerlink" title="100 个 10万数据的顺序表，怎么合并成一个新的顺序表？"></a>100 个 10万数据的顺序表，怎么合并成一个新的顺序表？</h4><p><a href="https://leetcode.cn/problems/merge-sorted-array/">合并两个有序数组</a>，直接说了，问是什么时间复杂度<br>O（100n） ？</p><p>不是太确定，说是对的</p><h4 id="长URL-映射到短URL"><a href="#长URL-映射到短URL" class="headerlink" title="长URL 映射到短URL"></a>长URL 映射到短URL</h4><p>刚开始不知道问的什么意思，说了半天也没理解，最后问了答案才知道是啥意思。<br>就是一个长URL通过62位编码转换成短URL，网上有相关的解释，不放了</p><h4 id="问项目、问实习"><a href="#问项目、问实习" class="headerlink" title="问项目、问实习"></a>问项目、问实习</h4><p>这里还行，挖的不是很深，感觉面试官只要觉得这里你是懂得就不深究，很松。</p><h3 id="反问"><a href="#反问" class="headerlink" title="反问"></a>反问</h3><h4 id="第二题是什么意思？答案是什么"><a href="#第二题是什么意思？答案是什么" class="headerlink" title="第二题是什么意思？答案是什么"></a>第二题是什么意思？答案是什么</h4><h4 id="部门的技术栈是Golang吗？"><a href="#部门的技术栈是Golang吗？" class="headerlink" title="部门的技术栈是Golang吗？"></a>部门的技术栈是Golang吗？</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一面&quot;&gt;&lt;a href=&quot;#一面&quot; class=&quot;headerlink&quot; title=&quot;一面&quot;&gt;&lt;/a&gt;一面&lt;/h2&gt;&lt;p&gt;总共分为三个环节&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自我介绍&lt;/li&gt;
&lt;li&gt;简历提问&lt;/li&gt;
&lt;li&gt;算法考查&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 </summary>
      
    
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/categories/%E9%9D%A2%E7%BB%8F/"/>
    
    
    <category term="面经" scheme="http://xiaoheinotes.com/tags/%E9%9D%A2%E7%BB%8F/"/>
    
    <category term="服务端开发" scheme="http://xiaoheinotes.com/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
</feed>
