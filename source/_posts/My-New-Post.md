---
title: 进程、线程、协程基础知识
date: 2023-09-14 21:11:55
categories:
  - 八股文
tags: 
- 操作系统
- 进程 
- 线程 
- 协程
---

Golang后端选手， 最近秋招有点难受，复习一下八股，就从进程开始吧（主要内容来自小林coding）

## 进程

通常来说，我们编写的代码会被存储成静态文件。通过编译后就会变成一些二进制的可执行文件。当这些文件被运行时，就会被装载到内存中去。
此时cpu就会执行这些程序的指令。这个运行的程序就被称为了**进程**。

通常来说，程序执行的时候往往会有些读取硬盘文件的操作。这些操作所花费的时候虽然在我们人的感受中没多少。但是对于被压榨的CPU来说，就是休息的有点多了。

这个时候进程就被提出来，可不可以在CPU等待时候，中断当前进程。去执行另一个进程。这样CPU也不会歇太长时间。我们能更好的压榨了^-^

![cpu进程切换](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/4-%E8%BF%9B%E7%A8%8B%E4%BA%A4%E6%9B%BF%E8%BF%90%E8%A1%8C.jpg)

所以多进程的思想就被提出来了

于是就有了一个必会的八股知识

### 并行和并发？

不多说 看图
![并发与并行](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/5-%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C.jpg)

当单核CPU通过多个进程切换来做，这样可以减少CPU休息的时间。CPU休息少了，任务自然就做的多了（太真实了有木有T-T）

### 进程的状态

进程既然要切换，那我们可以把这些状态按照不同情况进行分类。整体如下

![进程状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81.jpg)

归纳一下

- 运行状态: 此时进程控制着CPU
- 阻塞状态: 此时进程正在等待某个事件的发生，此时没有压榨CPU
- 就绪状态：完事具备，只欠东风了，就缺个CPU
- 创建状态：刚被创建
- 结束状态：进程即将消失

既然进程不在运行的时候。那这些进程要放到哪里。如果放到内存里。那个这个内存小身板可能有点顶不住了。而且这从整个操作系统视角来看就是再浪费内存的资源。所以一些操作系统会在进程阻塞的时候将内存换到物理磁盘里。反正物理磁盘里够折腾。

![缓存换页](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/9-%E6%8D%A2%E5%85%A5%E6%8D%A2%E5%87%BA.jpg)

本着节约的精神。增加了换盘的部分。所以就又增加了两个状态。

- 就绪挂起状态：进程在硬盘中挂起等待某个事件出现
- 阻塞挂起状态：进程在硬盘中等待，只要进入内存就能立即就绪

![新增的状态](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg)

## 进程的控制结构

### 进程在操作系统中是怎么被控制的呢？

是通过PCB 进程控制块描述进程的。其数据结构就是线性链表

### PCB包含什么信息？

进程描述信息

- 进程标识符： 标识进程
- 用户标识符： 标识进行归属的用户

进程控制及管理信息：

- 进程当前的状态
- 进程的优先级 （调度算法中所必须的）

资源分配清单

- 内存地址或虚拟地址的信息，所打开文件的列表和所使用的I/O设备信息

CPU相关信息

- CPU寄存器的信息。当进程切换时，为了保证下次能知道CPU的状态。所以需要将CPU当时的状态信息存到PCB中，下次执行就能准确无误的到断点执行

### PCB队列如何组织的？

一般来说是通过链表进行组织的。其次要按照进程的不同状态进行分类。比如就绪状态单独做一个队列，阻塞单独做一个阻塞队列。多种状态同时构建。这样就能很轻松的实现前面所说的进程状态转换问题了。**多核CPU用几个核就要用创建几个队列**

![PCB组织](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/12-PCB%E7%8A%B6%E6%80%81%E9%93%BE%E8%A1%A8%E7%BB%84%E7%BB%87.jpg)

一般情况下会选择链表去实现，因为要考虑到怎么去处理进程的取消、创建、状态转换。所以一定要实现灵活的插入和删除。

## 进程的控制

维护进程队列的结构一般为链表。那进程状态的转换要怎么实现？

创建进程

操作系统允许一个进程创建一个子进程。子进程会继承父进程的所拥有资源

- 创建一个空白PCB，填写进程信息
- 分配运行时的资源
- 插入就绪队列，等待运行

终止进程

一般来说一个进程的终止有三种状态。

1. 正常终止
2. 异常终止
3. kill
   
当进程要结束后。其继承的资源要还给父进程（通过系统回收：回收内存，关闭文件描述符等等）。当父进程被终止时，子进程就会变成孤儿进程，就需要交给1号进程进行回收。否则子进程就会变成僵尸进程

- 查找PCB
- 终止执行
- 有子进程交给1号进程收养
- 将进程资源交给系统回收
- PCB删除

阻塞进程

当进程需要等待某个事件的发生，就需要把自己阻塞。一旦进入阻塞状态，就必须让其他进程唤醒

- 根据标识号找到PCB
- 如果为运行态，就把当前的上下文存到PCB里，再转为阻塞态
- 加入到阻塞队列中

唤醒进程

当阻塞进程在事件发生后，被其他进程唤醒，类似接班人。只有CPU的运行才能有进程的进入

- 找到PCB
- 移除阻塞队列，转入就绪队列
- 等待调度

## 进程的上下文切换

当不同进程切换时，进程进行切换时，就会出现上下文切换

### 什么是CPU上下文切换？

所谓的上下文就是CPU寄存器和程序计数器在执行任务前所必须的依赖环境。需要知道上次进程执行的状态

所以CPU上下文切换就是将CPU寄存器和程序计数器中的内容在切换时保存到PCB中，加载时从PCB中加载到寄存器和程序计数器中。实现任务原封不动的切换。

### 进程上下文切换是什么？

进程是由内核调度的，进程的切换只能发生在内核态。

进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

注意：进程的上下文切换比较大，所以接下来提出了线程切换

### 发生进程上下文切换有哪些场景？

- 系统的自动调度，根据CPU时间片自动切换
- 进程资源不足，挂起等待资源充足
- Sleep主动挂起
- 高优先级进程插队
- 硬中断（外设、错误、时钟、外部信号、通知）

## 线程

必须要记得一个知识点：CPU的最小调度基本单位是  **线程**

### 为什么使用线程？

线程相比进程的好处在于上下文切换快和通信方便，它们共享进程的内容。上下文切换也只需要CPU切换

### 什么是线程？

一句话： **线程是进程当中的一条执行流程**

同一个进程内，多个线程可以共享代码段、数据段、打开的文件等资源。但每个线程各自都有独立的寄存器和栈。确保线程的控制是独立的

![线程的执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/16-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.jpg)

### 线程的优缺点？

优点：

- 进程可以存在多个线程
- 线程之间可以并发运行
- 线程可以共享地址空间和文件资源

缺点：

- 一般情况下线程崩溃且没有捕捉错误时会导致进程崩溃

### 线程和进程的比较

线程与进程的比较如下：

- 进程是资源的调度单位 线程是cpu的调度单位
- 进程拥有完整的资源平台，而线程只独享最小的资源
- 线程同样具有就绪、阻塞、运行三个状态
- 线程更加轻量，资源转换更方便

线程减少开销体现在：

- 线程创建快，线程不需要去创建资源，直接使用进程的
- 线程终止快 不需要去清理资源，这些都是交给进程的
- 线程切换快 因为线程只需要进行CPU上下文切换
- 线程内部交互快， 因为同一进程内部资源共享

### 线程上下文的切换是什么？

重复一遍， 进程是资源的基本调度单位， 线程是CPU的基本调度单位

操作系统的任务调度对象就是线程。进程是提供资源的

当两个线程切换是同一个进程里的话就很简单，只需要切换CPU上下文
当两个线程不是同一个进程，需要进程切换

### 线程如何实现的？

主要有三种线程的实现方式

- 用户线程：用户态线程库来完成线程的管理
- 内核线程：由内核管理的线程
- 轻量级线程： 内核中支持用户线程

### 用户线程如何理解？存在什么优势和缺陷？

用户线程的整个线程的管理和调度，操作系统是不会参与的。而是由用户级线程库函数来完成线程的调用管理。这个线程库函数怎么理解呢？

我是这么理解的，一般来说多个线程会对上一个内核线程。这时候线程库函数就是一个管理者，他会去安排这些线程加入到内核空间的线程中。
比如Golang的协程就是用户态线程的一种实现，它的线程管理全部由用户去管理，自然也就更高效了

![用户线程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/20-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E5%A4%9A%E5%85%B3%E7%B3%BB.jpg)

优点：

- 基于用户级线程库函数维护的，即时操作系统不支持线程，也可以并发
- 无需用户态和内核态的切换，速度比较快

缺点：

- 由于操作系统没法管理，出现阻塞、死锁等问题。无法处理
- 用户态线程无法打断当前运行中的线程。
- 由于调度时间片多层分割，分到进程，在分到线程。更少了，执行就会有一些不必要的麻烦

### 那内核线程如何理解？存在什么优势和缺陷？

什么是内核线程？

内核线程是由操作系统管理的，线程对应的 TCB 自然是放在操作系统里的，这样线程的创建、终止和管理都是由操作系统负责。

![内核态线程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/21-%E7%BA%BF%E7%A8%8BPCB-%E4%B8%80%E5%AF%B9%E4%B8%80%E5%85%B3%E7%B3%BB.jpg)

优点：

- 在一个进程中，如果某个内核线程发起系统调用，并不影响其他内核线程的运行
- 分配给线程，多线程的进程获得更多的CPU运行时间

缺点：

- 需要在支持内核线程的系统中使用，由内核维护PCB和TCB
- 线程的创建、终止和切换都是通过系统调用的方式来进行，因此对于系统来说，系统开销比较大；

### 轻量级进程如何理解？

轻量级进程（是内核支持的用户线程，一个进程可有一个或多个 LWP，每个 LWP 是跟内核线程一对一映射的，也就是 LWP 都是由一个内核线程支持，而且 LWP 是由内核管理并像普通进程一样被调度。

![轻量级进程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/22-LWP.jpg)

简单来讲就是用户空间模拟进程。通过cpu去实现的

## go协程

前面也讲了，协程实际上就是用户态线程的实现，用户态线程实现的区别主要是看线程怎么管理的。管理的好坏，也就决定了并发的好坏。go协程的实现，主要基于它的GMP模型。

![GMP模型](/image/image.png)

网上有一张GMP模型的展示我感觉很不错，可以用来演示。

### 什么是GMP模型？

- `G` 代表我们在代码中用`go`字段启动的协程
- `M` 代表内核线程
- `P` 代表我们的处理器，其主要由GOMAXPROCS字段指定

```go
// 通过runtime中的GOMAXPROCS字段 指定其数量
runtime.GOMAXPROCS(4)
```

通过GMP可以实现一个高并发量的用户态线程模式

### GMP模型怎么运行的？

- 全局队列：存放等待的运行的G
- P的本地队列：同全局队列类似，存放的也是等待运行的 G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。
- P的数量：由GOMAXPROCS指定，默认为CPU核数
- M：线程想运行任务就得获取 P，从 P 的本地队列获取 G。如果线程在运行阻塞时会创建新的线程

### P和M的数量？

P的数量有GOMAXPROCS决定
M的数量由当前运行阻塞度决定

### P 和 M 何时会被创建？

P在确定数量后，运行系统时就开始创建
M 则是在没有足够的M去关联P并运行时，会创建新的M。比如阻塞M后就会新建M

### 调度器是怎么设计的？

**复用线程**：避免频繁创建、销毁线程

1. workSteal机制 ：当本地无可运行的G时，会尝试从其他线程绑定的P中偷取G，并不去销毁
2. hand off 机制：当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。

**利用并行**：`GOMAXPROCS` 设置 `P` 的数量，最多有 `GOMAXPROCS` 个线程分布在多个 `CPU` 上同时运行。`GOMAXPROCS` 也限制了并发的程度，比如 `GOMAXPROCS` = 核数/2，则最多利用了一半的 CPU 核进行并行。

**抢占**: 在 `coroutine` 中要等待一个协程主动让出 `CPU` 才执行下一个协程，在 `Go` 中，一个 `goroutine` 最多占用 `CPU` 10ms，防止其他 `goroutine` 被饿死，这就是 `goroutine` 不同于 `coroutine` 的一个地方。

**全局 G 队列**: 在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。

### M0 和 G0 有什么特点？

`M0` 是启动程序后的编号为 `0` 的主线程，这个 `M` 对应的实例会在全局变量 `runtime.m0` 中，不需要在 `heap` 上分配，`M0` 负责执行初始化操作和启动第一个 `G`， 在之后 `M0` 就和其他的 M 一样了。

`G0` 是每次启动一个 `M` 都会第一个创建的 `gourtine`，`G0` 仅用于负责调度的 `G`，`G0` 不指向任何可执行的函数，每个 `M` 都会有一个自己的 `G0`。在调度或系统调用时会使用 `G0` 的栈空间，全局变量的 `G0` 是 `M0` 的 `G0`

### 怎么可视化GMP编程

`go tool trace` 可以记录运行时的信息，能提供可视化的Web界面

简单测试代码：main 函数创建 trace，trace 会运行在单独的 goroutine 中，然后 main 打印”Hello World” 退出。

`main.go`

```go
package main

import (
	"fmt"
	"os"
	"runtime/trace"
)

func main() { //创建trace文件
	f, err := os.Create("trace.out")
	if err != nil {
		panic(err)
	}
	defer f.Close()
	//启动trace goroutine
	err = trace.Start(f)
	if err != nil {
		panic(err)
	}
	defer trace.Stop()
	//main
	fmt.Println("Hello World")
}

```

运行程序

```shell
go run main.go Hello World
```

会得到一个 trace.out 文件，然后我们可以用一个工具打开，来分析这个文件。

```shell
go tool trace trace.out
```

就会打开分析这个文件， 点击view trace， 就能看到协程的执行情况


## 结语

大概理了一下进程、线程、协程之间的关系。其实还是有很多东西需要去理解，这里只是八股文的一个总结。如果想知道更为翔实的内容，还得是翻源码呀。

🐀🐀我太弱了，还需要努力T-T