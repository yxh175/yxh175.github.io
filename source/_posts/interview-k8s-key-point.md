---
title: 面试重点：k8s相关面试题
date: 2023-10-12 11:23:56
cover: https://s2.loli.net/2023/10/12/ibQxlXJZOyY8aKu.png
categories:
- 八股文
tags:
- k8s
---

学习K8S前建议先学习过docker或者快速阅读一下这篇文章![Docker面试总结](http://xiaoheinotes.com/2023/10/07/interview-docker-key-point/)

## K8S 是什么？

Kubernetes是一个容器编排平台，用于自动化容器化应用程序的部署、扩展、管理和维护。Kubernetes提供了负载均衡、自动伸缩、服务发现等功能，以便有效地管理大规模的容器部署。基本是云厂商不可或缺的一个工具了

## Docker和K8S的关系是什么？

Docker和K8S之间是一种协同的关系，Docker负责应用级的容器构建、打包，K8S负责容器编排和容器管理

### Docker：容器化平台

- 容器引擎：通过Docker Engine实现容器的构建、打包、运行。提供容器的生命周期
- 容器镜像：通过容器镜像实现沙箱化模式，让容器可以轻松的在不同环境下部署

### K8S 容器管理平台

- 部署与管理容器：Kubernetes 可以自动化地管理和编排容器的部署、伸缩和更新，确保应用程序高可用性和可伸缩性。
- 服务编排：Kubernetes可以定义、部署和管理多个容器的组合，以构建复杂的应用程序。
- 资源管理：Kubernetes可以有效地管理计算、存储和网络资源，以满足应用程序的需求。
- 自动运维：Kubernetes支持自动化的容器部署、恢复、扩展和滚动升级。

## 主机上部署和容器上部署有什么区别吗？

![主机与容器部署的区别](https://s2.loli.net/2023/10/12/ZTovOg6XGRcmsx9.png)

### 结构区别

首先最明显的就是隔离性的区别

左侧架构表示用主机直接部署的老方法，所有的应用程序依赖都基于主机的一个软件库。

右侧架构即是容器架构，容器架构将有一个内核，这是所有应用程序唯一共享的底层。每个应用程序的底层都是自己独立的软件库，保证了每个应用程序的隔离性

### 部署速度

主机直接部署需要先安装各个应用程序所需要的依赖。导致安装更复杂，部署困难问题

容器部署 则不需要考虑这么多，只需要构建对应的镜像即可

### 可移植性

主机部署模式下，应用程序如果想切换主机，就需要重新去部署。甚至还可能会遇到版本不同步的问题

容器部署模式下，通过打包，将应用程序和依赖封装在一个标准化的容器中，可以在不同环境进行运行

## 什么是容器编排（Container Orchestration）？

虽然容器有很多好处，但是有一个缺点，就是微服务的情况下，容器是相互独立。这就意味着容器之间无法去进行通信。为了解决这个问题？

于是在上层即K8S实现容器的编排，即一种管理和协调容器化应用程序的自动化过程。

通过这种手段的实现，最后实现整个微服务构建的容器之间的互相通信问题。同时还可以实现一些功能性的组件并实现容器的日志监控

## K8S 有什么特点

- 自动化编排：Kubernetes能够自动化容器的部署、伸缩、升级和维护，大大减少了运维负担。
- 容器抽象：Kubernetes引入了容器抽象，容器化的应用程序在K8s中被视为一个单一的实体，从而简化了管理和操作。
- 自我修复：K8s能够自动检测和恢复故障容器、节点或整个集群，确保应用程序的高可用性。
- 负载均衡：Kubernetes支持负载均衡，可以将流量均匀分布到容器实例之间，提高应用程序的可伸缩性和性能。
- 自动伸缩：K8s允许根据负载自动扩展或缩减容器实例的数量，以满足应用程序的需求。
- 容器网络：Kubernetes提供容器之间的通信和网络隔离，允许容器安全地互相通信。
- 配置管理：Kubernetes支持配置管理，容器的配置和环境变量可以在部署期间灵活配置。

看着好像是一长串，但实际上这些特点都是有迹可循的

首先自动化编排不用说，K8S的核心要素。自动化编排去编排什么？ 抽象的实例，用**容器**去实现。既然K8S已经可以实现容器的编排了。那如果容器进程崩溃要怎么办，这时就需要K8S去进行重启。这就是**自我修复**功能。但是我们直到微服务往往是集群模式，所以可扩展也是必须要求的，所以就可以进行**自动伸缩**允许我们去控制实例的重复数量。既然微服务有集群模式，那是不是要进行负载均衡去解决这个问题。所以K8S也有**负载均衡**的作用。最后就是统一配置了通过K8S的编排，可以配置容器内部的环境变量，这样在容器部署期间就可以灵活的**配置**

## K8S架构是什么样的？

和大多数分布式系统一样，K8S集群至少需要一个主节点（Master）和多个计算节点（Node）

- 主节点主要用于暴露API，调度部署和节点的管理
- 计算节点运行一个容器运行环境，同时运行一个K8s的代理（kubelet）用于和master通信。计算节点也会运行一些额外的组件，像记录日志，节点监控，服务发现等等。计算节点是k8s集群中真正工作的节点。

### Master节点

- Kubectl：客户端命令行工具，作为整个K8s集群的操作入口
- Api Server：在K8s架构中承担的是“桥梁”的角色，作为资源操作的唯一入口，它提供了认证、授权、访问控制、API注册和发现等机制。客户端与k8s群集及K8s内部组件的通信，都要通过Api Server这个组件
- Controller-manager：负责维护群集的状态，比如故障检测、自动扩展、滚动更新等
- Scheduler：负责资源的调度，按照预定的调度策略将pod调度到相应的node节点上
- Etcd：担任数据中心的角色，保存了整个群集的状态

### Node节点

- Kubelet：负责维护容器的生命周期，同时也负责Volume和网络的管理，一般运行在所有的节点，是Node节点的代理，当Scheduler确定某个node上运行pod之后，会将pod的具体信息（image，volume）等发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向master返回运行状态。（自动修复功能：如果某个节点中的容器宕机，它会尝试重启该容器，若重启无效，则会将该pod杀死，然后重新创建一个容器
- Kube-proxy：Service在逻辑上代表了后端的多个pod。负责为Service提供cluster内部的服务发现和负载均衡（外界通过Service访问pod提供的服务时，Service接收到的请求后就是通过kube-proxy来转发到pod上的）
- container-runtime：是负责管理运行容器的软件，比如docker
- Pod：是k8s集群里面最小的单位。每个pod里边可以运行一个或多个container（容器），如果一个pod中有两个container，那么container的USR（用户）、MNT（挂载点）、PID（进程号）是相互隔离的，UTS（主机名和域名）、IPC（消息队列）、NET（网络栈）是相互共享的。我比较喜欢把pod来当做豌豆夹，而豌豆就是pod中的container

## kubenetes针对pod资源对象的健康监测机制？

- livenessProbe探针

可以根据用户自定义规则来判定pod是否健康，如果livenessProbe探针探测到容器不健康，则kubelet会根据其重启策略来决定是否重启，如果一个容器不包含livenessProbe探针，则kubelet会认为容器的livenessProbe探针的返回值永远成功。

- ReadinessProbe探针

同样是可以根据用户自定义规则来判断pod是否健康，如果探测失败，控制器会将此pod从对应service的endpoint列表中移除，从此不再将任何请求调度到此Pod上，直到下次探测成功。

- startupProbe探针

启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉，这个问题也可以换另一种方式解决，就是定义上面两类探针机制时，初始化时间定义的长一些即可。

## 如何控制滚动更新过程？

此参数控制滚动更新过程，副本总数超过预期pod数量的上限。可以是百分比，也可以是具体的值。默认为1。

