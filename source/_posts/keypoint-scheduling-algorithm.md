---
title: 面试重点：系统调度算法
date: 2023-10-16 10:03:03
categories: 
- 八股
tags:
- 调度算法
---

本文主要参考[小林coding](https://xiaolincoding.com/os/5_schedule/schedule.html#%E9%AB%98%E5%93%8D%E5%BA%94%E6%AF%94%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95)

操作系统存在三大调度

- 进程调度：对于CPU使用的调度
- 页面置换：对于虚拟内存的调度
- 磁盘调度：对于硬盘的调度

对进程调度做一个大致的总结

## 进程调度算法

对CPU的调度，解决问题的出发点是如何最好的任务的执行时间和等待时间

### 先来先服务调度算法

最简单的一个调度算法，非抢占的先来先服务算法。

依照队列排序的顺序，先来就先服务。但是这个时候会出现一个问题，就是长作业会占用CPU较长的时间，而导致后面短作业的等待时间会很长

基于这种缺点，于是最短作业优先调度就被提出来了

### 最短作业优先调度算法

最短作业调度算法是一种典型的贪心算法，它会优先选择运行时间最短的进程来运行，提高系统的吞吐量

缺点也显而易见，就是对长作业会形成一个饥饿现象，极端情况下，大量繁琐且不重要的短作业会导致长作业无法被CPU调度

可以看到两者都没法很好的去平衡短作业和长作业之间的关系

### 高响应比优先调度算法

为了权衡短作业和长作业之间的调度问题，提出了高相应比优先调度算法，其主要基于一个等待时间和要求服务时间的计算得出一个优先权，通过优先权下一个调度的对象

![高响应比优先调度算法](https://s2.loli.net/2023/10/16/ZcCNF953bx1z8su.png)

### 时间片轮转调度算法

当然除了非抢占式，还存在并发系统中的时间片轮转调度算法，每个进程被分配一个时间段，称为时间片，即允许该进程在该时间段中运行。

- 如果时间运行结束那么将会把此进程从CPU中释放出来，并把CPU分配到另外一个进程
- 如果出现阻塞或结束，则马上进行切换

![时间片轮转](https://s2.loli.net/2023/10/16/QIoYVmw3DhPt4OK.png)

对于运行时间的设置也是一个关键问题

- 时间片设置过长，退化成先来先服务调度算法
- 时间片设置过短，导致CPU执行过多的进程上下文切换，降低了CPU效率

通常设置一个`20ms-50ms`的值是一个合理的折中值

### 最高优先级调度算法

时间片轮转调度算法，认为所有的进程的分配时间片应该是相同。但是在实际操作系统，某些进程应该被分配更多的时间片。因为其进程往往是最重要的

进程的优先级可以分为，静态优先级或动态优先级

- 静态优先级：创建进程时，就已经确定了优先级了，然后整个运行时间优先级都不会变化。
- 动态优先级：根据进程的动态变化调整优先级，比如如果进程运行时间增加，则降低其优先级，如果进程等待时间（就绪队列的等待时间）增加，则升高其优先级，也就是随着时间的推移增加等待进程的优先级。

同时该算法也有两种处理高优先级的方法，非抢占式与抢占式

- 非抢占式：当就绪队列中出现优先级高的进程，运行完当前进程，再选择优先级高的进程
- 抢占式：就绪队列中出现优先级高的进程，当前进程挂起，调度优先级高的进程去运行

但这样也是有缺点的，即低优先级的进程运行的概率很小

### 多级反馈队列调度算法

对于时间片和最高优先级两种调度算法都有自己的问题

- 时间片轮转太过于公平，以至于没有了优先级
- 最高优先级又矫枉过正，导致低优先级运行概率小，甚至极端情况会出现不运行的情况

所以综合两者的问题，提出了多级反馈队列调度算法，其核心要点主要是两个：多级、反馈

- 多级：即有多个队列，每个队列的优先级不同，同时优先级越高时间片越短
- 反馈：如果有新的进程加入优先级高的队列，立刻停止当前正在运行的进程，转而去运行优先级高的队列

![多级反馈队列](https://s2.loli.net/2023/10/16/HwRdFW7forJek1Y.png)

它的运行流程是这样的，新进程刚进来是优先最高，时间片最短的。每一次获取时间片结束后都会使他进入下一个优先级低的队列，但是时间片也会被增长。所以该算法很好的**兼顾了长短作业，同时有较好的响应时间**

## 内存置换算法

内存置换算法是一个常考点，它主要服务于操作系统中，因为物理内存与硬盘的映射关系存在一定的大小，当CPU访问的页面不在物理内存时，便会产生一个缺页中断，请求操作系统将所缺页调入到物理内存中。与一般的中断区别是：

- 缺页中断在指令执行期间产生和处理中断信号，而一般中断在一条指令执行完成后检查和处理中断信号
- 缺页中断在返回回去仍然执行该指令，其他中断则是在指向下一指令

其流程如下：

![内存置换算法](https://s2.loli.net/2023/10/16/Y3bU4NxeIknfljv.png)

1. Load指令去查找页表
2. 页表状态位为无效的，触发中断请求
3. 操作系统查找磁盘对应页面位置
4. 加载到物理内存中
5. 修改页表项的状态位
6. 重新执行导致异常的指令

### 最佳页面置换算法(OPT)

最佳页面置换算法的思路，就是替换掉未来最长时间不访问的页面，但是操作系统往往不知道未来访问的情况，所以这个算法是没法实现的

### 先进先出置换算法(FIFO)

先进先出就用了一个队列进行模拟，队尾是新的，队头是要被清除的，通常的实现方法是**链表实现**

### 最近最久未使用 LRU

删除掉最进最久为使用的，听起来貌似好像很绕，实际换种说法就很容易理解，即选中最长时间没有被访问的页面进行置换。有点类似最佳页面置换算法，但是区别在于是基于已知的页面击中情况进行处理的。

![最近最久未使用](https://s2.loli.net/2023/10/16/LV7NPC9aSOqucJ8.png)

一般来说它的实现方法，是有一个双向链表加上一个set集合实现。实现的代价是比较大的。队头代表最新访问，队尾代表最久未被访问

### 时钟页面置换算法

那有没有一种即能优化置换的次数，也能方便实现的算法呢？

时钟页面置换算法就可以两者兼得，它跟 LRU 近似，又是对 FIFO 的一种改进。

该算法的思路是，把所有的页面都保存在一个类似钟面的「环形链表」中，一个表针指向最老的页面。

### 最不常用算法 LFU

最不常用算法指的发送页面中断时，清除掉访问次数最小的那个页面

LFU 算法只考虑了频率问题，没考虑时间的问题，比如有些页面在过去时间里访问的频率很高，但是现在已经没有访问了，而当前频繁访问的页面由于没有这些页面访问的次数高，在发生缺页中断时，就会可能会误伤当前刚开始频繁访问，但访问次数还不高的页面。

