---
title: 面试重点知识点：TCP相关
date: 2023-09-21 11:24:42
categories:
- 八股文
tags:
- 计算机网络
- TCP
---

本文主要参考[小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)

## TCP 基本认识

### TCP头格式有哪些？

说几个重点的

- seq 序列号：解决网络包乱序问题
- 确认应答号：解决丢包问题
- 控制位：表示状态
    1. ACK：确认应答
    2. SYN：建立连接
    3. RST：异常断开
    4. FIN: 正常结束

### TCP工作了哪一层？为什么这么多应用层都用它？

TCP工作在传输层，为应用层服务。
大多数应用层都用它的原因是因为IP层只保证两点之间的连接，但是无法保证整个报文的正常交付，所以需要提升一个层面去监督IP的传输过程。保证传输的可靠性

### TCP是什么？

一种传输协议，它有以下三个特点

- 面向连接： 一对一连接
- 可靠的： 保证报文的正常交互
- 基于字节流的： 字节流传输，可能会出现粘包的问题

### 什么是TCP连接？

TCP 连接简单来说就是用于保证可靠性和流量控制的一些状态，总共有三个

- socket： 保证两个主机之间能够连接
- 序列号： 保证了不会乱序
- 窗口大小： 实现流量控制

### 如何确定一个TCP连接？

通过四元组

（源地址，源端口，目的地址，目的端口）

#### TCP理论的最大连接数？

理论最大连接数 = 客户端IP数*服务端端口数

但是系统的最大并发数是有限制的

- 在linux系统中一个TCP连接算一个文件，会导致文件描述符（Linux指向文件的指针表）被占满
- 内存会OOM

### UDP和TCP 的区别？ 场景的区别？

TCP 和UDP的区别主要有七个点

- 有无连接： TCP是有连接， UDP无连接
- 可靠性： TCP保证报文的交付，UDP不保证
- 连接数： TCP是1对1， UDP是可以1对1或者1对多的
- 拥塞控制、流量控制： TCP有这些，UDP无法感知对方的接收（QUIC除外）
- 首部开销： TCP 首部有端口、序列号、状态码， UDP 只有端口号、包长度、校验号
- 传输方式： TCP是流式传输， UDP是包进行发送，是有边界的，但可能会乱序
- 分片不同：TCP 为了保证可靠性会进行分片，UDP则在IP层分片，自己不关心分片


TCP的应用场景

- FTP 文件传输
- HTTP/ HTTPS

UDP的场景

- 包总量少的通信 DNS、SNMP
- 即时视频、音频
- 广播通信

#### 为什么UDP 头部有包长度，TCP没有？

TCP可以计算出来
TCP 数据长度 = IP总长度 - IP头 - TCP头

UDP 为了快，所以不想这么计算，直接用空间换时间

#### 为什么TCP 有首部长度，UDP没有？

UDP是固定的
TCP 是有可选选项字段的

### TCP 和UDP 能共用字段吗？ 为什么？

可以，操作系统存在两种传输协议，两种协议在内核种使用了两种软件模块

![传输层](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg)

网络层会根据报文的头按照两种协议，分别传给UDP模块和TCP模块，两者最后传输给两类端口

## TCP连接建立

### TCP 怎么建立三次握手？

![三次握手](https://img1.imgtp.com/2023/09/26/brzne9QG.png)

- 客户端发送SYN 及序列号 X， 进入SYN_SENT 此时不收到ACK就会超时重传
- 服务端收到后回复 ACK 及 seq = Y 及 Ack NUM = X+1 进入 SYN_RCVD
- 客服端收到后，会发送ACK ack = Y + 1 创建完成， 服务端收到后也会创建完成

注意：第三次握手可以携带数据，前两次握手不可以携带

### 如何在Linux系统中查看TCP状态？

TCP 连接状态，在Linux可以通过`netstat -napt`查看

### 为什么是三次握手，不是两次或者四次？

- 避免历史连接：如果每次都相同的话，会导致
- 同步双方初始序列号
- 避免资源浪费

两次握手：无法避免历史连接的建立，会造成双方资源的消费，也无法可靠的同步双方序列号
四次握手：三次握手就可以实现了，不需要冗余的通信次数

### 为什么每次建立TCP连接时，初始化序列号要求不一样？

- 防止历史报文被下一个相同四元组连接接收
- 为了安全性，随机的序列号不易被黑客攻击

### 初始序列号 ISN 是如何随机产生的？

ISN 基于时钟产生的

ISN = M + F(四元组)

- M 是计时器 每隔4微妙+1
- F 是HASH算法，根据四元组生成一个随机值

### IP层会分片了，为什么还要TCP层进行分片

TCP头部要每次都传，不然如果进行整个的切分，会导致数据丢失无法被定位

### 第一次握手丢失了，会发生什么？

第一次握手丢失，此时客户端已经发送SYN请求，进入SYN_SENT 状态。这种状态下会在一定时间下进行重试，每次重试时间是上一次的两倍。直到超过默认的最大时间。此时如果发送成功，就继续TCP连接，否则重复发送直到TCP连接断开

### 第二次握手丢失了，会发生什么？

第二次握手丢失时，此时客户端在SYN_SENT状态，服务端在SYN_RCYD状态。这个时候，客户端是不知道服务端已经收到了消息，所以客户端会进行多次SYN_SENT的请求，同时服务端也会进行多次SYN_ACK。两者都会不断的发送消息。

### 第三次握手丢失了，会发送什么？

ACK报文不会重传，此时会等待服务端重复发送SYN_ACK 每次发送后，客户端接收到都会发送一个ACK。如果没有丢失就进入连接，否则就会进入堵塞

### 什么是SYN攻击？如何避免SYN攻击？

TCP 连接会有一个半连接队列，用来记录接收客户端SYN的报文

![TCP连接队列](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)

正常流程：

1. 服务端接收客户端的SYN报文，会创建一个半连接对象，然后加入到SYN队列（半连接队列）中
2. 发送SYN+ACK给客户端
3. 接收到客户端ACK后，从半连接队列中取出一个，根据其创建一个全连接对象，放入到Accept队列中
4. 应用调用accept()的socket接口，从Accept队列中取出对象使用

SYN攻击方式最直接的方式就是把半连接队列打满，这样更容易实现，客户端只需要提出连接就可。多次提交都没有问题。导致半连接队列满了后，就没法在接收之后的连接请求了

如何避免：

- 调大消息缓存队列
- 增大TCP半连接队列
- 开启syncookies
- 减少SYN_ACK的重传次数


## TCP连接断开

### TCP的四次挥手过程

![四次挥手](https://img1.imgtp.com/2023/09/27/gEbtacy0.png)

- 客户端申请关闭， 发送`FIN`进入`FIN_WAIT_1`
- 服务端收到请求后，发送`ACK`，进入`CLOSE_WAIT`进行资源结束，客户端收到`ACK`进入`FIN_WAIT_1`
- `CLOSE_WAIT`结束后，表示服务端已经正确的关闭了所有资源。发送`FIN`，进入`LAST_ACK`
- 客服端收到`FIN` 后发送`ACK`。此时进入`TIME_Wait` 等待`2MS`后进入`CLOSE`态。服务端在收到`ACK`后进入`CLOSE`态

### 为什么挥手四次？

需要去进行一个资源的关闭，这一个资源的关闭导致了ACK和FIN是分开发送的。

### 第一次挥手丢失了，会发生什么？

第一次挥手丢失，服务端是无感知的，所以客户端会执行超时重传

### 第二次挥手丢失了，会发生什么？

第二次挥手丢失，此时服务端已经进入了CLOSED_WAIT， 客户端在FIN_WAIT_1阶段。在客户端的视角，它还是无法感知是否已经发送过去，所以它会进行FIN的持续发送。