---
title: 面试重点知识点：TCP相关
date: 2023-09-21 11:24:42
categories:
- 八股文
tags:
- 计算机网络
- TCP
---

本文主要参考[小林coding](https://xiaolincoding.com/network/3_tcp/tcp_interview.html#tcp-%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B)

## TCP 基本认识

### TCP头格式有哪些？

说几个重点的

- seq 序列号：解决网络包乱序问题
- 确认应答号：解决丢包问题
- 控制位：表示状态
    1. ACK：确认应答
    2. SYN：建立连接
    3. RST：异常断开
    4. FIN: 正常结束

### TCP工作了哪一层？为什么这么多应用层都用它？

TCP工作在传输层，为应用层服务。
大多数应用层都用它的原因是因为IP层只保证两点之间的连接，但是无法保证整个报文的正常交付，所以需要提升一个层面去监督IP的传输过程。保证传输的可靠性

### TCP是什么？

一种传输协议，它有以下三个特点

- 面向连接： 一对一连接
- 可靠的： 保证报文的正常交互
- 基于字节流的： 字节流传输，可能会出现粘包的问题

### 什么是TCP连接？

TCP 连接简单来说就是用于保证可靠性和流量控制的一些状态，总共有三个

- socket： 保证两个主机之间能够连接
- 序列号： 保证了不会乱序
- 窗口大小： 实现流量控制

### 如何确定一个TCP连接？

通过四元组

（源地址，源端口，目的地址，目的端口）

#### TCP理论的最大连接数？

理论最大连接数 = 客户端IP数*服务端端口数

但是系统的最大并发数是有限制的

- 在linux系统中一个TCP连接算一个文件，会导致文件描述符（Linux指向文件的指针表）被占满
- 内存会OOM

### UDP和TCP 的区别？ 场景的区别？

TCP 和UDP的区别主要有七个点

- 有无连接： TCP是有连接， UDP无连接
- 可靠性： TCP保证报文的交付，UDP不保证
- 连接数： TCP是1对1， UDP是可以1对1或者1对多的
- 拥塞控制、流量控制： TCP有这些，UDP无法感知对方的接收（QUIC除外）
- 首部开销： TCP 首部有端口、序列号、状态码， UDP 只有端口号、包长度、校验号
- 传输方式： TCP是流式传输， UDP是包进行发送，是有边界的，但可能会乱序
- 分片不同：TCP 为了保证可靠性会进行分片，UDP则在IP层分片，自己不关心分片


TCP的应用场景

- FTP 文件传输
- HTTP/ HTTPS

UDP的场景

- 包总量少的通信 DNS、SNMP
- 即时视频、音频
- 广播通信

#### 为什么UDP 头部有包长度，TCP没有？

TCP可以计算出来
TCP 数据长度 = IP总长度 - IP头 - TCP头

UDP 为了快，所以不想这么计算，直接用空间换时间

#### 为什么TCP 有首部长度，UDP没有？

UDP是固定的
TCP 是有可选选项字段的

### TCP 和UDP 能共用字段吗？ 为什么？

可以，操作系统存在两种传输协议，两种协议在内核种使用了两种软件模块

![传输层](https://cdn.xiaolincoding.com/gh/xiaolincoder/network/port/tcp%E5%92%8Cudp%E6%A8%A1%E5%9D%97.jpeg)

网络层会根据报文的头按照两种协议，分别传给UDP模块和TCP模块，两者最后传输给两类端口

## TCP连接建立

### TCP 怎么建立三次握手？

![三次握手](https://img1.imgtp.com/2023/09/26/brzne9QG.png)

- 客户端发送SYN 及序列号 X， 进入SYN_SENT 此时不收到ACK就会超时重传
- 服务端收到后回复 ACK 及 seq = Y 及 Ack NUM = X+1 进入 SYN_RCVD
- 客服端收到后，会发送ACK ack = Y + 1 创建完成， 服务端收到后也会创建完成

注意：第三次握手可以携带数据，前两次握手不可以携带

### 如何在Linux系统中查看TCP状态？

TCP 连接状态，在Linux可以通过`netstat -napt`查看

### 为什么是三次握手，不是两次或者四次？

- 避免历史连接：如果每次都相同的话，会导致
- 同步双方初始序列号
- 避免资源浪费

两次握手：无法避免历史连接的建立，会造成双方资源的消费，也无法可靠的同步双方序列号
四次握手：三次握手就可以实现了，不需要冗余的通信次数

### 为什么每次建立TCP连接时，初始化序列号要求不一样？

- 防止历史报文被下一个相同四元组连接接收
- 为了安全性，随机的序列号不易被黑客攻击

### 初始序列号 ISN 是如何随机产生的？

ISN 基于时钟产生的

ISN = M + F(四元组)

- M 是计时器 每隔4微妙+1
- F 是HASH算法，根据四元组生成一个随机值

### IP层会分片了，为什么还要TCP层进行分片

TCP头部要每次都传，不然如果进行整个的切分，会导致数据丢失无法被定位

### 第一次握手丢失了，会发生什么？

第一次握手丢失，此时客户端已经发送SYN请求，进入SYN_SENT 状态。这种状态下会在一定时间下进行重试，每次重试时间是上一次的两倍。直到超过默认的最大时间。此时如果发送成功，就继续TCP连接，否则重复发送直到TCP连接断开

### 第二次握手丢失了，会发生什么？

第二次握手丢失时，此时客户端在SYN_SENT状态，服务端在SYN_RCYD状态。这个时候，客户端是不知道服务端已经收到了消息，所以客户端会进行多次SYN_SENT的请求，同时服务端也会进行多次SYN_ACK。两者都会不断的发送消息。

### 第三次握手丢失了，会发送什么？

ACK报文不会重传，此时会等待服务端重复发送SYN_ACK 每次发送后，客户端接收到都会发送一个ACK。如果没有丢失就进入连接，否则就会进入堵塞

### 什么是SYN攻击？如何避免SYN攻击？

TCP 连接会有一个半连接队列，用来记录接收客户端SYN的报文

![TCP连接队列](https://cdn.xiaolincoding.com//mysql/other/format,png-20230309230622886.png)

正常流程：

1. 服务端接收客户端的SYN报文，会创建一个半连接对象，然后加入到SYN队列（半连接队列）中
2. 发送SYN+ACK给客户端
3. 接收到客户端ACK后，从半连接队列中取出一个，根据其创建一个全连接对象，放入到Accept队列中
4. 应用调用accept()的socket接口，从Accept队列中取出对象使用

SYN攻击方式最直接的方式就是把半连接队列打满，这样更容易实现，客户端只需要提出连接就可。多次提交都没有问题。导致半连接队列满了后，就没法在接收之后的连接请求了

如何避免：

- 调大消息缓存队列
- 增大TCP半连接队列
- 开启syncookies
- 减少SYN_ACK的重传次数


## TCP连接断开

### TCP的四次挥手过程

![四次挥手](https://img1.imgtp.com/2023/09/27/gEbtacy0.png)

- 客户端申请关闭， 发送`FIN`进入`FIN_WAIT_1`
- 服务端收到请求后，发送`ACK`，进入`CLOSE_WAIT`进行资源结束，客户端收到`ACK`进入`FIN_WAIT_1`
- `CLOSE_WAIT`结束后，表示服务端已经正确的关闭了所有资源。发送`FIN`，进入`LAST_ACK`
- 客服端收到`FIN` 后发送`ACK`。此时进入`TIME_Wait` 等待`2MS`后进入`CLOSE`态。服务端在收到`ACK`后进入`CLOSE`态

### 为什么挥手四次？

需要去进行一个资源的关闭，这一个资源的关闭导致了ACK和FIN是分开发送的。

### 第一次挥手丢失了，会发生什么？

第一次挥手丢失，服务端是无感知的，所以客户端会执行超时重传

### 第二次挥手丢失了，会发生什么？

第二次挥手丢失，此时服务端已经进入了CLOSED_WAIT， 客户端在FIN_WAIT_1阶段。在客户端的视角，它还是无法感知是否已经发送过去，所以它会进行FIN的多次重传。每次重传都会回一个ACK。直到ACK被接收

### 第三次挥手丢失了，会发送什么？

第三次挥手，是服务端结束本地资源向客户端发送FIN的一个过程，此时客户端进入了一个FIN_WAIT_2劫夺，如果得不到ACK，客户端会一直四等，但是会在`60s`结束等待直接进入close。而服务端会进行多次重传，直到重传次数被用完。

### 第四次挥手丢失了，会发送什么？

第四次挥手，是客户端收到服务端发送FIN请求后回的ACK进入2MS的TIME_WAIT。此时服务端在LAST_ACK中，此时服务端如果没有收到ACK会多次重传向客户端发送FIN请求。每一次重置请求都会让TIME_WAIT的计时器重置。

### TIME_WAIT的时间？

2MSL（Maximum Segment Lifetime）即报文在网络中的最大生存时间。因为报文在网络传输中，会对他内部的TTL进行-1.当TTL为0的时候节点就会对其丢弃。

#### TTL是什么？

TTL 是 IP头部中的一个字段，每一次经过一个节点时，都会将TTL减1保证报文，不会在网络空间中无限循环。如果TTL为0时就会被抛弃在网络空间中

#### TTL 和 MSL的区别？

TTL 是一个值，用来判断报文是否应该被抛弃，MSL是一个表象，是表示报文TTL消失到0的时间。一般来说`MSL`要设置的比`TTL`所需要的时间大，防止出现了误判

#### 为什么是2MSL，不是直接是MSL？

首先是因为，这是两个来回，需要客户端发送一次后，服务端给他返回一个。这样才能结束，需要两个MSL

### 为什么需要TIME_WAIT?

- 防止历史的连接的数据被新的连接错误的接收：因为序列号是有上下限的，可能出现序列绕回的情况
- 保证被动关闭的一方能够正常的关闭：确保ACK被服务端收到，否则服务端进入LAST_ACK进行多次FIN请求的发送。而进入异常终止的状态

### TIME_WAIT过多有什么害处？

TIME_WAIT是主动关闭的一方最终结束状态。此时TIME_WAIT过多有两个危害

- 占用系统资源
- 占用端口资源

### 如何优化TIME_WAIT?

- `net.ipv4.tcp_tw_reuse` 和 `tcp_timestamps`

开启此参数可以复用TIME_WAIT的socket作为新的连接所用

tcp_tw_reuse 功能只能用客户端（连接发起方），因为开启了该功能，在调用 connect() 函数时，内核会随机找一个 time_wait 状态超过 1 秒的连接给新的连接复用。

- net.ipv4.tcp_max_tw_buckets

这个值默认为 18000，当系统中处于 TIME_WAIT 的连接一旦超过这个值时，系统就会将后面的 TIME_WAIT 连接状态重置，这个方法比较暴力。

- 程序中使用 `SO_LINGER`

使用此选项会直接跳过`TIME_WAIT`，不过并不是太推荐

### 服务器出现大量TIME_WAIT的原因有哪些？

- HTTP没有使用长连接
- HTTP长连接超时
- HTTP长连接请求数量达到上限

#### 客户端禁用Keep-Alive，服务端开启 HTTP Keep-Alive，谁是主动关闭方？

服务端会主动关闭

当客户端禁用了 `HTTP Keep-Alive`，这时候 `HTTP` 请求的 `header` 就会有 `Connection:close` 信息，这时服务端在发完 `HTTP` 响应后，就会主动关闭连接。

其实也很容易理解：发起方是客户端，客户端的要求不能拒绝，所以就不开启Keep-Alive

#### 客户端开启了 HTTP Keep-Alive，服务端禁用了 HTTP Keep-Alive，谁是主动关闭方？

服务端主动关闭

当客户端开启了 `HTTP Keep-Alive`，而服务端禁用了 `HTTP Keep-Alive`，这时服务端在发完 `HTTP` 响应后，服务端也会主动关闭连接。

也很好理解，客服端的要求服务端无法满足也只能不`Keep-Alive`

