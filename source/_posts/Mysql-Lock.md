---
title: mysql锁介绍
date: 2023-09-15 21:32:56
categories:
- 八股文
tags:
- mysql
- 锁
- 并发安全
---

# Mysql 锁

现在后端对高并发的要求很高。当时暑期实习面腾讯云智、小米都被问到Redis怎么实现分布式锁。我当时寻思我写的是了解啊。

不吹水了，看看Mysql的锁机制怎么实现（内容参考小林Coding）

## 全局锁

全局锁就是将mysql整个数据库锁住（很暴力）

### 全局锁怎么用的？

要使用全局锁，需要执行这个命令

```mysql
flush tables with read lock
```

整个数据库会进入只读状态
任何增、删、改的操作都会被阻塞

解锁使用

```mysql
unlock tables
```

还有一种解锁方法，是命令发起者的会话断开

### 全局锁的应用场景是什么？

全局锁一般用在全局备份上, 因为此时数据在备份是无法在一瞬间备份的。万一头尾数据存在一致性关联。可能会出现头备份完成，尾部修改导致的数据不一致

### 加全局锁的缺点是什么？

全局锁，意味着整个数据库是只读状态。这样只能读不能写，一定情况下会影响业务。

### 除了加全局锁备份，还有其他备份方式吗？

`MVCC`后面会介绍到，`Mysql`的灵魂。通过`ReadView`进行备份

如何操作？

使用`mysqldump`工具，在使用`mysqldump`时加上`–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。

## 表级锁

### Mysql表级锁有哪些？具体怎么用的

Mysql表级锁大概有四个

- 表锁
- 元数据锁
- 意向锁
- AUTO-INC锁

#### 表锁

表锁就是加在整个表的锁

```mysql
// 读锁
lock table t_student read;
// 写锁
lock table t_student write;

// 释放当前会话的锁
unlock tables
```

#### 元数据锁

首先要知道什么是元数据呢？

元数据（Metadata）是关于数据的数据，它提供了关于数据的描述、定义和管理信息。元数据通常用于帮助组织、理解、搜索和管理数据（数据库对象结构、表、索引等）

所以元数据锁的出现就是为了保证用户在对表执行CRUD操作时，防止其他线程对这个表结构进行了更改

一般来说，我们不需要显示的去调用

- 变更结构 加写锁
- CRUD 加读锁

当执行Select时语句时会加MDL读锁，接下来所有结构更变操作都会被阻塞
当执行结构更变操作时，所有的CRUD也会被阻塞

#### MDL不会显示调用，那什么时候会释放？

MDL 是在事务提交后释放，事务执行期间，MDL是一直持续的

但是事务过长可能也会导致一些异常

举个例子

1. 线程A启动事务，执行一个Select语句，此时开启了读锁，且不提交事务，所也就不会释放
2. 线程B这时候执行Select语句则不会被阻塞
3. 线程C修改表字段，此时又要加写锁，但又申请不到写锁，就会阻塞
4. 此时C的写锁阻塞会导致之后不管是写锁还是读锁都会阻塞

#### 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

因为申请MDL锁的操作是一个队列，且队列中写锁的优先级更高，一旦申请不到写锁，按照排序来说，必须要等到写锁申请到后面的读锁才能申请。这里设计到一些饥饿锁的知识

所以安全的操作结构的方法，是在做表结构更变时看看是不是存在长事务MDL锁，有的话可以Kill掉。让它一会再查

### 意向锁

#### 意向锁是什么？

当执行插入、更新、删除操作，需要先对表加上一个意向锁。

注意Select一般情况下是不会加锁的，因为Select走的是MVCC

也可以强行操作让Select走意向锁

```mysql
//先在表上加上意向共享锁，然后对读取的记录加共享锁
select ... lock in share mode;

//先表上加上意向独占锁，然后对读取的记录加独占锁
select ... for update;
```

#### 为什么设置意向锁？

意向锁主要是和表锁发生冲突，mysql为了判断一个表内有没有加锁，使用意向锁进行快速查找

#### AUTO-INC锁

innoDB早期版本，使用的这种锁，在`AUTO_INCREMENT`字段自增时会加入进去，会在整个语句执行完毕后释放锁

现在版本使用的是一种轻量锁，这种轻量的锁会在自增字段值赋值完毕后，马上就释放了

但是这种方法虽然更快一点。也会有些缺点。在主从复制模式下。如果出现下面这个场景就会出现异常

![主从复制异常](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/innodb_autoinc_lock_mode=2.png)

看最后一行，可能出现如下情况

- sessionB 加入两个值
- 此时sessionA 也加入了一个值
- sessionB 把剩余的值加入

可以看到这个id是不连续的。如果`binlog`记录的是原始语句那么这个自增字段可能就会不一样。解决方法是将`inlog_format`设置为row，binlog就会记录主库分配的自增值

## 行级锁

`InnoDB` 引擎是支持行级锁的，而 `MyISAM` 引擎并不支持行级锁。

如果加行锁了后，同时也会在表级加意向锁

- Record Lock 记录锁
- Gap Lock 间隙锁
- Next-Key Lock 临键锁

### Record Lock

就是X和S两种情况的兼容，比较容易理解

![记录锁](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E8%AE%B0%E5%BD%95%E9%94%81.drawio.png)

### Gap Lock

间隙锁为了防止出现幻读。二者不互斥

![间隙锁](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png)

### Next-Key Lock 临键锁

是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

![临键锁](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png)

会出现XS兼容问题

### 插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。
如果有的话，插入操作就会发生阻塞，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个插入意向锁，表明有事务想在某个区间插入新记录，但是现在处于等待状态。（车票中的候补票。）

## 参考资料

[小林coding](https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81)