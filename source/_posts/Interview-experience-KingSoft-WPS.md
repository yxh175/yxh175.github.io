---
title: 面经：金山办公服务端开发
date: 2023-09-22 12:56:12
categories: 
- 面经
tags:
- 面经
- 服务端开发
---

## 一面

总共分为三个环节

- 自我介绍
- 简历提问
- 算法考查

### 自我介绍

首先自我介绍了一下

### 提问环节

先是问一下比较基础的八股，然后逐渐变难的

#### IP层有哪些协议？

- DNS 用来根据域名进行网络查询
- ARP 根据IP查询点之间的mac地址
- DHCP 自动分配IP地址
- NAT 私有地址转换为外网地址
- ICMP 确认IP包是否成功送达到目标地址
- IGMP

#### 讲一下TCP的三次握手

TCP三次握手即客户端和服务端连接时，两个者进行三次沟通的过程

- 客户端发送SYNC + 随机seq序列号X
- 服务端监听到后回复ACK+SYNC ACK num= X+1 SeqNum = Y 
- 客户端收到后， 回复ACK Ack num = Y+1

#### 为什么TCP连接要有seq序列号？

- 在TCP三次握手中保证了三次握手检查，不会有历史连接干扰
- 在传输时能进行报文的控制，方便进行拥塞控制、丢失重传、流量控制

#### 讲一下四次挥手

TCP 四次挥手是客户端和服务端断开，进行的一个操作，保证TCP连接的正常断开

假设客户端主动关闭的时候

- 客户端发送FIN请求 seq = x、ack = y
- 服务端收到FIN请求，回复ACK seq = y 、ack = x+1，进入Close_Wait并结束进程，进行最后的资源释放
- 等资源处理完毕后，发送FIN seq = y、ack = x + 1
- 此时客户端会进入Time_Wait状态发送ACK  seq = x + 1， ack = y + 1

发送成功后，两者就进行了正常关闭

#### 为什么要有Time_Wait状态？

- 防止历史连接的数据影响新的连接，要让本次报文中的数据尽可能的在网络中消失掉。
- 保证被关闭的一方能够正确的关闭，多次监听服务端的消息，如果服务端再次发送关闭请求到客户端，说明自己的发送失败了。需要确保对方成功关闭

#### HTTP协议中一般有哪些状态码

- 1XX 属于提示信息，协议处理的中间态，一般用到的比较少
- 2XX 表示成功处理客户端的请求，是我们最想看到的如：200、204
- 3XX 表示资源发生了变动，如：301、302、304
- 4XX 表示客户端发送的报文有误如 404 资源不存在
- 5XX 表示服务端内部异常 如 500、501、502、503

#### 499 状态码是做什么的有了解吗？

这个没答上来。回答了说平时只了解过40x左右的。开发的时候没怎么见过

随后搜索：
499， Client Closed Request
这个表示客户端主动断开连接
是指一次http请求在客户端指定的时间内没有返回响应，此时客户端会主动断开连接，此时表象为客户端无响应返回，而nginx的日志会status code 499

#### 讲一下HTTPS的协议？

HTTPS 是基于HTTP的明文传输与不安全。所以在TCP三次握手后增加了TSL层作数据安全性的保证，通过TSL四次握手进行对称密钥的生成，实现对话过程中的加密。HTTPS可以保证主要用来保证信息的机密性、摘要算法的方式实现完整性、数字证书解决被冒充的方法

#### HTTPS 能被抓包吗？

我理解错了他的意思，以为问的是HTTPS能被窃听吗，所以回答成了：在保证对话密钥不被窃取，证书没有伪造的情况下。是不会被抓包的

理论答案：
可以通过抓包调试，通过抓包工具，并在手机中放好证书。保证系统能使用这个证书的情况下，就可以抓取到Https的内容

#### 有没有用过HTTPS抓包？

当时脑子抽抽了，以为把抓包的意思理解错了，说没有T-T 实际上还是有的

正确回答：
通过抓包工具，把证书下载好，设置拦截端口号并拦截所发送的请求。即可得到解密后的包

#### Golang 的GMP调度模式？

可以参考这篇文档[Go GMP](https://juejin.cn/post/7044741465930465311)的图解，讲的非常清楚。为了方便，我就直接用他的图了

golang 的GMP调度老生常谈了

- G goroutine 代表程序中的协程
- M machine 代表内核线程
- P process 代表处理器

P 会有一些本地队列，根据MAXPROCES 确定P的数量，P本地有个本地队列，用来存放协程。通过调用M来使用协程能够在M上运行。这样能保证M的线程能够多次复用，而且更加轻量。
为了保证协程资源分配的均匀提出了两个机制

- hand off 机制当本地线程M1因为G进行的系统调用阻塞时，线程释放绑定的P， 把P转移给其他空闲的M0执行

![hand off 机制](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3df5d4f14311450dada8f4d6da82b896~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

- work stealing 机制

当本线程无G可运行时，从其他线程绑定的P窃取G，而不是直接销毁线程

![work stealing 机制](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d5b7c21037ed401292ec01aadfd906ea~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

#### 怎么保证一个协程能一直占用一个CPU？

加自旋锁让协程一直占用CPU